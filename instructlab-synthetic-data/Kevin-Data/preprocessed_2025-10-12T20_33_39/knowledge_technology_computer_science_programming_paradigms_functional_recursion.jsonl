{"document": "Recursion_(computer_science)\nIn computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion solves such recursive problems by using functions that call themselves from within their own code. The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions.\nMost computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages (for instance, Clojure) do not define any looping constructs but rely solely on recursion to repeatedly call code. It is proved in computability theory that these recursive-only languages are Turing complete; this means that they are as powerful (they can be used to solve the same problems) as imperative languages based on control structures such as while and for.\nRepeatedly calling a function from within itself may cause the call stack to have a size equal to the sum of the input sizes of all involved calls. It follows that, for problems that can be solved easily by iteration, recursion is generally less efficient, and, for certain problems, algorithmic or compiler-optimization techniques such as tail call optimization may improve computational performance over a naive recursive implementation.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nIn computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion solves such recursive problems by using functions that call themselves from within their own code. The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions.\nMost computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages (for instance, Clojure) do not define any looping constructs but rely solely on recursion to repeatedly call code. It is proved in computability theory that these recursive-only languages are Turing complete; this means that they are as powerful (they can be used to solve the same problems) as imperative languages based on control structures such as while and for.\nRepeatedly calling a function from within itself may cause the call stack to have a size equal to the sum of the input sizes of all involved calls. It follows that, for problems that can be solved easily by iteration, recursion is generally less efficient, and, for certain problems, algorithmic or compiler-optimization techniques such as tail call optimization may improve computational performance over a naive recursive implementation.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nIn computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion solves such recursive problems by using functions that call themselves from within their own code. The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions.\nMost computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages (for instance, Clojure) do not define any looping constructs but rely solely on recursion to repeatedly call code. It is proved in computability theory that these recursive-only languages are Turing complete; this means that they are as powerful (they can be used to solve the same problems) as imperative languages based on control structures such as while and for.\nRepeatedly calling a function from within itself may cause the call stack to have a size equal to the sum of the input sizes of all involved calls. It follows that, for problems that can be solved easily by iteration, recursion is generally less efficient, and, for certain problems, algorithmic or compiler-optimization techniques such as tail call optimization may improve computational performance over a naive recursive implementation.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nIn computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion solves such recursive problems by using functions that call themselves from within their own code. The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions.\nMost computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages (for instance, Clojure) do not define any looping constructs but rely solely on recursion to repeatedly call code. It is proved in computability theory that these recursive-only languages are Turing complete; this means that they are as powerful (they can be used to solve the same problems) as imperative languages based on control structures such as while and for.\nRepeatedly calling a function from within itself may cause the call stack to have a size equal to the sum of the input sizes of all involved calls. It follows that, for problems that can be solved easily by iteration, recursion is generally less efficient, and, for certain problems, algorithmic or compiler-optimization techniques such as tail call optimization may improve computational performance over a naive recursive implementation.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nIn computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion solves such recursive problems by using functions that call themselves from within their own code. The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions.\nMost computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages (for instance, Clojure) do not define any looping constructs but rely solely on recursion to repeatedly call code. It is proved in computability theory that these recursive-only languages are Turing complete; this means that they are as powerful (they can be used to solve the same problems) as imperative languages based on control structures such as while and for.\nRepeatedly calling a function from within itself may cause the call stack to have a size equal to the sum of the input sizes of all involved calls. It follows that, for problems that can be solved easily by iteration, recursion is generally less efficient, and, for certain problems, algorithmic or compiler-optimization techniques such as tail call optimization may improve computational performance over a naive recursive implementation.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nA common algorithm design tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method; when combined with a lookup table that stores the results of previously solved sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nA common algorithm design tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method; when combined with a lookup table that stores the results of previously solved sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nA common algorithm design tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method; when combined with a lookup table that stores the results of previously solved sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nA common algorithm design tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method; when combined with a lookup table that stores the results of previously solved sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nA common algorithm design tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method; when combined with a lookup table that stores the results of previously solved sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nBase case\nA recursive function definition has one or more base cases, meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases, meaning input(s) for which the program recurs (calls itself).  For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n − 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones.  In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached.  (Functions that are not intended to terminate under normal circumstances—for example, some system and server processes—are an exception to this.)  Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop.\nFor some functions (such as one that computes the series for e = 1/0! + 1/1! + 1/2! + 1/3! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by corecursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the nth term (nth partial sum)\".", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nBase case\nA recursive function definition has one or more base cases, meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases, meaning input(s) for which the program recurs (calls itself).  For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n − 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones.  In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached.  (Functions that are not intended to terminate under normal circumstances—for example, some system and server processes—are an exception to this.)  Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop.\nFor some functions (such as one that computes the series for e = 1/0! + 1/1! + 1/2! + 1/3! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by corecursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the nth term (nth partial sum)\".", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nBase case\nA recursive function definition has one or more base cases, meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases, meaning input(s) for which the program recurs (calls itself).  For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n − 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones.  In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached.  (Functions that are not intended to terminate under normal circumstances—for example, some system and server processes—are an exception to this.)  Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop.\nFor some functions (such as one that computes the series for e = 1/0! + 1/1! + 1/2! + 1/3! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by corecursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the nth term (nth partial sum)\".", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nBase case\nA recursive function definition has one or more base cases, meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases, meaning input(s) for which the program recurs (calls itself).  For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n − 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones.  In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached.  (Functions that are not intended to terminate under normal circumstances—for example, some system and server processes—are an exception to this.)  Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop.\nFor some functions (such as one that computes the series for e = 1/0! + 1/1! + 1/2! + 1/3! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by corecursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the nth term (nth partial sum)\".", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive functions and algorithms\nBase case\nA recursive function definition has one or more base cases, meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases, meaning input(s) for which the program recurs (calls itself).  For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n − 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones.  In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached.  (Functions that are not intended to terminate under normal circumstances—for example, some system and server processes—are an exception to this.)  Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop.\nFor some functions (such as one that computes the series for e = 1/0! + 1/1! + 1/2! + 1/3! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by corecursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the nth term (nth partial sum)\".", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nMany computer programs must process or generate an arbitrarily large quantity of data.  Recursion is a technique for representing data whose exact size is unknown to the programmer: the programmer can specify this data with a self-referential definition.  There are two types of self-referential definitions: inductive and coinductive definitions.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nMany computer programs must process or generate an arbitrarily large quantity of data.  Recursion is a technique for representing data whose exact size is unknown to the programmer: the programmer can specify this data with a self-referential definition.  There are two types of self-referential definitions: inductive and coinductive definitions.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nMany computer programs must process or generate an arbitrarily large quantity of data.  Recursion is a technique for representing data whose exact size is unknown to the programmer: the programmer can specify this data with a self-referential definition.  There are two types of self-referential definitions: inductive and coinductive definitions.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nMany computer programs must process or generate an arbitrarily large quantity of data.  Recursion is a technique for representing data whose exact size is unknown to the programmer: the programmer can specify this data with a self-referential definition.  There are two types of self-referential definitions: inductive and coinductive definitions.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nMany computer programs must process or generate an arbitrarily large quantity of data.  Recursion is a technique for representing data whose exact size is unknown to the programmer: the programmer can specify this data with a self-referential definition.  There are two types of self-referential definitions: inductive and coinductive definitions.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nInductively defined data\nAn inductively defined recursive data definition is one that specifies how to construct instances of the data.  For example, linked lists can be defined inductively (here, using Haskell syntax):\nThe code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings.  The self-reference in the definition permits the construction of lists of any (finite) number of strings.\nAnother example of inductive definition is the natural numbers (or positive integers):\nA natural number is either 1 or n+1, where n is a natural number.\nSimilarly recursive definitions are often used to model the structure of expressions and statements in programming languages.  Language designers often express grammars in a syntax such as Backus–Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:\nThis says that an expression is either a number, a product of two expressions, or a sum of two expressions.  By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complicated arithmetic expressions such as (5 * ((3 * 6) + 8)), with more than one product or sum operation in a single expression.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nInductively defined data\nAn inductively defined recursive data definition is one that specifies how to construct instances of the data.  For example, linked lists can be defined inductively (here, using Haskell syntax):\nThe code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings.  The self-reference in the definition permits the construction of lists of any (finite) number of strings.\nAnother example of inductive definition is the natural numbers (or positive integers):\nA natural number is either 1 or n+1, where n is a natural number.\nSimilarly recursive definitions are often used to model the structure of expressions and statements in programming languages.  Language designers often express grammars in a syntax such as Backus–Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:\nThis says that an expression is either a number, a product of two expressions, or a sum of two expressions.  By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complicated arithmetic expressions such as (5 * ((3 * 6) + 8)), with more than one product or sum operation in a single expression.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nInductively defined data\nAn inductively defined recursive data definition is one that specifies how to construct instances of the data.  For example, linked lists can be defined inductively (here, using Haskell syntax):\nThe code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings.  The self-reference in the definition permits the construction of lists of any (finite) number of strings.\nAnother example of inductive definition is the natural numbers (or positive integers):\nA natural number is either 1 or n+1, where n is a natural number.\nSimilarly recursive definitions are often used to model the structure of expressions and statements in programming languages.  Language designers often express grammars in a syntax such as Backus–Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:\nThis says that an expression is either a number, a product of two expressions, or a sum of two expressions.  By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complicated arithmetic expressions such as (5 * ((3 * 6) + 8)), with more than one product or sum operation in a single expression.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nInductively defined data\nAn inductively defined recursive data definition is one that specifies how to construct instances of the data.  For example, linked lists can be defined inductively (here, using Haskell syntax):\nThe code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings.  The self-reference in the definition permits the construction of lists of any (finite) number of strings.\nAnother example of inductive definition is the natural numbers (or positive integers):\nA natural number is either 1 or n+1, where n is a natural number.\nSimilarly recursive definitions are often used to model the structure of expressions and statements in programming languages.  Language designers often express grammars in a syntax such as Backus–Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:\nThis says that an expression is either a number, a product of two expressions, or a sum of two expressions.  By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complicated arithmetic expressions such as (5 * ((3 * 6) + 8)), with more than one product or sum operation in a single expression.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nInductively defined data\nAn inductively defined recursive data definition is one that specifies how to construct instances of the data.  For example, linked lists can be defined inductively (here, using Haskell syntax):\nThe code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings.  The self-reference in the definition permits the construction of lists of any (finite) number of strings.\nAnother example of inductive definition is the natural numbers (or positive integers):\nA natural number is either 1 or n+1, where n is a natural number.\nSimilarly recursive definitions are often used to model the structure of expressions and statements in programming languages.  Language designers often express grammars in a syntax such as Backus–Naur form; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:\nThis says that an expression is either a number, a product of two expressions, or a sum of two expressions.  By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complicated arithmetic expressions such as (5 * ((3 * 6) + 8)), with more than one product or sum operation in a single expression.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nCoinductively defined data and corecursion\nA coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.\nA coinductive definition of infinite streams of strings, given informally, might look like this:\nA stream of strings is an object s such that:\nhead(s) is a string, and\ntail(s) is a stream of strings.\nThis is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the accessor functions head and tail—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.\nCorecursion is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects.  As a programming technique, it is used most often in the context of lazy programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown.  In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result.  The problem of computing the first n prime numbers is one that can be solved with a corecursive program (e.g. here).", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nCoinductively defined data and corecursion\nA coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.\nA coinductive definition of infinite streams of strings, given informally, might look like this:\nA stream of strings is an object s such that:\nhead(s) is a string, and\ntail(s) is a stream of strings.\nThis is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the accessor functions head and tail—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.\nCorecursion is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects.  As a programming technique, it is used most often in the context of lazy programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown.  In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result.  The problem of computing the first n prime numbers is one that can be solved with a corecursive program (e.g. here).", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nCoinductively defined data and corecursion\nA coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.\nA coinductive definition of infinite streams of strings, given informally, might look like this:\nA stream of strings is an object s such that:\nhead(s) is a string, and\ntail(s) is a stream of strings.\nThis is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the accessor functions head and tail—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.\nCorecursion is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects.  As a programming technique, it is used most often in the context of lazy programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown.  In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result.  The problem of computing the first n prime numbers is one that can be solved with a corecursive program (e.g. here).", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nCoinductively defined data and corecursion\nA coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.\nA coinductive definition of infinite streams of strings, given informally, might look like this:\nA stream of strings is an object s such that:\nhead(s) is a string, and\ntail(s) is a stream of strings.\nThis is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the accessor functions head and tail—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.\nCorecursion is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects.  As a programming technique, it is used most often in the context of lazy programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown.  In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result.  The problem of computing the first n prime numbers is one that can be solved with a corecursive program (e.g. here).", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data types\nCoinductively defined data and corecursion\nA coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.\nA coinductive definition of infinite streams of strings, given informally, might look like this:\nA stream of strings is an object s such that:\nhead(s) is a string, and\ntail(s) is a stream of strings.\nThis is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the accessor functions head and tail—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.\nCorecursion is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects.  As a programming technique, it is used most often in the context of lazy programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown.  In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result.  The problem of computing the first n prime numbers is one that can be solved with a corecursive program (e.g. here).", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nSingle recursion and multiple recursion\nRecursion that contains only a single self-reference is known as single recursion, while recursion that contains multiple self-references is known as multiple recursion. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal, such as in a depth-first search.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.\nMultiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively entails multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, while tracking two successive values at each step – see corecursion: examples. A more sophisticated example involves using a threaded binary tree, which allows iterative tree traversal, rather than multiple recursion.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nSingle recursion and multiple recursion\nRecursion that contains only a single self-reference is known as single recursion, while recursion that contains multiple self-references is known as multiple recursion. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal, such as in a depth-first search.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.\nMultiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively entails multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, while tracking two successive values at each step – see corecursion: examples. A more sophisticated example involves using a threaded binary tree, which allows iterative tree traversal, rather than multiple recursion.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nSingle recursion and multiple recursion\nRecursion that contains only a single self-reference is known as single recursion, while recursion that contains multiple self-references is known as multiple recursion. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal, such as in a depth-first search.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.\nMultiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively entails multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, while tracking two successive values at each step – see corecursion: examples. A more sophisticated example involves using a threaded binary tree, which allows iterative tree traversal, rather than multiple recursion.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nSingle recursion and multiple recursion\nRecursion that contains only a single self-reference is known as single recursion, while recursion that contains multiple self-references is known as multiple recursion. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal, such as in a depth-first search.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.\nMultiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively entails multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, while tracking two successive values at each step – see corecursion: examples. A more sophisticated example involves using a threaded binary tree, which allows iterative tree traversal, rather than multiple recursion.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nSingle recursion and multiple recursion\nRecursion that contains only a single self-reference is known as single recursion, while recursion that contains multiple self-references is known as multiple recursion. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal, such as in a depth-first search.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.\nMultiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively entails multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, while tracking two successive values at each step – see corecursion: examples. A more sophisticated example involves using a threaded binary tree, which allows iterative tree traversal, rather than multiple recursion.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nIndirect recursion\nMost basic examples of recursion, and most of the examples presented here, demonstrate direct recursion, in which a function calls itself.  Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.\nIndirect recursion is also called mutual recursion, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nIndirect recursion\nMost basic examples of recursion, and most of the examples presented here, demonstrate direct recursion, in which a function calls itself.  Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.\nIndirect recursion is also called mutual recursion, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nIndirect recursion\nMost basic examples of recursion, and most of the examples presented here, demonstrate direct recursion, in which a function calls itself.  Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.\nIndirect recursion is also called mutual recursion, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nIndirect recursion\nMost basic examples of recursion, and most of the examples presented here, demonstrate direct recursion, in which a function calls itself.  Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.\nIndirect recursion is also called mutual recursion, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nIndirect recursion\nMost basic examples of recursion, and most of the examples presented here, demonstrate direct recursion, in which a function calls itself.  Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.\nIndirect recursion is also called mutual recursion, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nAnonymous recursion\nRecursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions, and is known as anonymous recursion.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nAnonymous recursion\nRecursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions, and is known as anonymous recursion.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nAnonymous recursion\nRecursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions, and is known as anonymous recursion.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nAnonymous recursion\nRecursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions, and is known as anonymous recursion.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nAnonymous recursion\nRecursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions, and is known as anonymous recursion.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nSome authors classify recursion as either \"structural\" or \"generative\".  The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:\n[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE  FUNCTIONS.\nThus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input.  Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.\nGenerative recursion is the alternative:\nMany well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HtDP (How to Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: gcd, quicksort, binary search, mergesort, Newton's method, fractals, and adaptive integration.\nThis distinction is important in proving termination of a function.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nSome authors classify recursion as either \"structural\" or \"generative\".  The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:\n[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE  FUNCTIONS.\nThus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input.  Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.\nGenerative recursion is the alternative:\nMany well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HtDP (How to Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: gcd, quicksort, binary search, mergesort, Newton's method, fractals, and adaptive integration.\nThis distinction is important in proving termination of a function.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nSome authors classify recursion as either \"structural\" or \"generative\".  The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:\n[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE  FUNCTIONS.\nThus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input.  Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.\nGenerative recursion is the alternative:\nMany well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HtDP (How to Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: gcd, quicksort, binary search, mergesort, Newton's method, fractals, and adaptive integration.\nThis distinction is important in proving termination of a function.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nSome authors classify recursion as either \"structural\" or \"generative\".  The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:\n[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE  FUNCTIONS.\nThus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input.  Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.\nGenerative recursion is the alternative:\nMany well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HtDP (How to Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: gcd, quicksort, binary search, mergesort, Newton's method, fractals, and adaptive integration.\nThis distinction is important in proving termination of a function.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nSome authors classify recursion as either \"structural\" or \"generative\".  The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:\n[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE  FUNCTIONS.\nThus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input.  Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.\nGenerative recursion is the alternative:\nMany well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HtDP (How to Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: gcd, quicksort, binary search, mergesort, Newton's method, fractals, and adaptive integration.\nThis distinction is important in proving termination of a function.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nAll structurally recursive functions on finite (inductively defined) data structures can easily be shown to terminate, via structural induction: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.\nGeneratively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.\nIn terms of loop variants, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.\nBy contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nAll structurally recursive functions on finite (inductively defined) data structures can easily be shown to terminate, via structural induction: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.\nGeneratively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.\nIn terms of loop variants, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.\nBy contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nAll structurally recursive functions on finite (inductively defined) data structures can easily be shown to terminate, via structural induction: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.\nGeneratively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.\nIn terms of loop variants, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.\nBy contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nAll structurally recursive functions on finite (inductively defined) data structures can easily be shown to terminate, via structural induction: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.\nGeneratively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.\nIn terms of loop variants, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.\nBy contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTypes of recursion\nStructural versus generative recursion\nAll structurally recursive functions on finite (inductively defined) data structures can easily be shown to terminate, via structural induction: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.\nGeneratively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.\nIn terms of loop variants, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.\nBy contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nIn actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:\nWrapper function (at top)\nShort-circuiting the base case, aka \"Arm's-length recursion\" (at bottom)\nHybrid algorithm (at bottom) – switching to a different algorithm once data is small enough\nOn the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nIn actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:\nWrapper function (at top)\nShort-circuiting the base case, aka \"Arm's-length recursion\" (at bottom)\nHybrid algorithm (at bottom) – switching to a different algorithm once data is small enough\nOn the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nIn actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:\nWrapper function (at top)\nShort-circuiting the base case, aka \"Arm's-length recursion\" (at bottom)\nHybrid algorithm (at bottom) – switching to a different algorithm once data is small enough\nOn the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nIn actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:\nWrapper function (at top)\nShort-circuiting the base case, aka \"Arm's-length recursion\" (at bottom)\nHybrid algorithm (at bottom) – switching to a different algorithm once data is small enough\nOn the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nIn actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:\nWrapper function (at top)\nShort-circuiting the base case, aka \"Arm's-length recursion\" (at bottom)\nHybrid algorithm (at bottom) – switching to a different algorithm once data is small enough\nOn the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nWrapper function\nA wrapper function is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.\nWrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as \"level of recursion\" or partial computations for memoization, and handle exceptions and errors. In languages that support nested functions, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using pass-by-reference.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nWrapper function\nA wrapper function is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.\nWrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as \"level of recursion\" or partial computations for memoization, and handle exceptions and errors. In languages that support nested functions, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using pass-by-reference.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nWrapper function\nA wrapper function is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.\nWrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as \"level of recursion\" or partial computations for memoization, and handle exceptions and errors. In languages that support nested functions, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using pass-by-reference.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nWrapper function\nA wrapper function is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.\nWrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as \"level of recursion\" or partial computations for memoization, and handle exceptions and errors. In languages that support nested functions, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using pass-by-reference.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nWrapper function\nA wrapper function is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.\nWrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as \"level of recursion\" or partial computations for memoization, and handle exceptions and errors. In languages that support nested functions, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using pass-by-reference.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\nShort-circuiting the base case, also known as arm's-length recursion, consists of checking the base case before making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short circuit, and may miss 0; this can be mitigated by a wrapper function. The box shows C code to shortcut factorial cases 0 and 1.\nShort-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for O(n) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only O(1) savings.\nConceptually, short-circuiting can be considered to either have the same base case and recursive step, checking the base case only before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely \"check valid then recurse\", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\nShort-circuiting the base case, also known as arm's-length recursion, consists of checking the base case before making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short circuit, and may miss 0; this can be mitigated by a wrapper function. The box shows C code to shortcut factorial cases 0 and 1.\nShort-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for O(n) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only O(1) savings.\nConceptually, short-circuiting can be considered to either have the same base case and recursive step, checking the base case only before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely \"check valid then recurse\", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\nShort-circuiting the base case, also known as arm's-length recursion, consists of checking the base case before making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short circuit, and may miss 0; this can be mitigated by a wrapper function. The box shows C code to shortcut factorial cases 0 and 1.\nShort-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for O(n) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only O(1) savings.\nConceptually, short-circuiting can be considered to either have the same base case and recursive step, checking the base case only before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely \"check valid then recurse\", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\nShort-circuiting the base case, also known as arm's-length recursion, consists of checking the base case before making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short circuit, and may miss 0; this can be mitigated by a wrapper function. The box shows C code to shortcut factorial cases 0 and 1.\nShort-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for O(n) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only O(1) savings.\nConceptually, short-circuiting can be considered to either have the same base case and recursive step, checking the base case only before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely \"check valid then recurse\", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\nShort-circuiting the base case, also known as arm's-length recursion, consists of checking the base case before making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short circuit, and may miss 0; this can be mitigated by a wrapper function. The box shows C code to shortcut factorial cases 0 and 1.\nShort-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for O(n) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only O(1) savings.\nConceptually, short-circuiting can be considered to either have the same base case and recursive step, checking the base case only before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely \"check valid then recurse\", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\n=### Depth-first search=\nA basic example of short-circuiting is given in depth-first search (DFS) of a binary tree; see binary trees section for standard recursive discussion.\nThe standard recursive algorithm for a DFS is:\nbase case: If current node is Null, return false\nrecursive step: otherwise, check value of current node, return true if match, otherwise recurse on children\nIn short-circuiting, this is instead:\ncheck value of current node, return true if match,\notherwise, on children, if not Null, then recurse.\nIn terms of the standard steps, this moves the base case check before the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).\nIn the case of a perfect binary tree of height h, there are 2h+1−1 nodes and 2h+1 Null pointers as children (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.\nIn C, the standard recursive algorithm may be implemented as:\nThe short-circuited algorithm may be implemented as:", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\n=### Depth-first search=\nA basic example of short-circuiting is given in depth-first search (DFS) of a binary tree; see binary trees section for standard recursive discussion.\nThe standard recursive algorithm for a DFS is:\nbase case: If current node is Null, return false\nrecursive step: otherwise, check value of current node, return true if match, otherwise recurse on children\nIn short-circuiting, this is instead:\ncheck value of current node, return true if match,\notherwise, on children, if not Null, then recurse.\nIn terms of the standard steps, this moves the base case check before the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).\nIn the case of a perfect binary tree of height h, there are 2h+1−1 nodes and 2h+1 Null pointers as children (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.\nIn C, the standard recursive algorithm may be implemented as:\nThe short-circuited algorithm may be implemented as:", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\n=### Depth-first search=\nA basic example of short-circuiting is given in depth-first search (DFS) of a binary tree; see binary trees section for standard recursive discussion.\nThe standard recursive algorithm for a DFS is:\nbase case: If current node is Null, return false\nrecursive step: otherwise, check value of current node, return true if match, otherwise recurse on children\nIn short-circuiting, this is instead:\ncheck value of current node, return true if match,\notherwise, on children, if not Null, then recurse.\nIn terms of the standard steps, this moves the base case check before the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).\nIn the case of a perfect binary tree of height h, there are 2h+1−1 nodes and 2h+1 Null pointers as children (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.\nIn C, the standard recursive algorithm may be implemented as:\nThe short-circuited algorithm may be implemented as:", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\n=### Depth-first search=\nA basic example of short-circuiting is given in depth-first search (DFS) of a binary tree; see binary trees section for standard recursive discussion.\nThe standard recursive algorithm for a DFS is:\nbase case: If current node is Null, return false\nrecursive step: otherwise, check value of current node, return true if match, otherwise recurse on children\nIn short-circuiting, this is instead:\ncheck value of current node, return true if match,\notherwise, on children, if not Null, then recurse.\nIn terms of the standard steps, this moves the base case check before the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).\nIn the case of a perfect binary tree of height h, there are 2h+1−1 nodes and 2h+1 Null pointers as children (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.\nIn C, the standard recursive algorithm may be implemented as:\nThe short-circuited algorithm may be implemented as:", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nShort-circuiting the base case\n=### Depth-first search=\nA basic example of short-circuiting is given in depth-first search (DFS) of a binary tree; see binary trees section for standard recursive discussion.\nThe standard recursive algorithm for a DFS is:\nbase case: If current node is Null, return false\nrecursive step: otherwise, check value of current node, return true if match, otherwise recurse on children\nIn short-circuiting, this is instead:\ncheck value of current node, return true if match,\notherwise, on children, if not Null, then recurse.\nIn terms of the standard steps, this moves the base case check before the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).\nIn the case of a perfect binary tree of height h, there are 2h+1−1 nodes and 2h+1 Null pointers as children (2 for each of the 2h leaves), so short-circuiting cuts the number of function calls in half in the worst case.\nIn C, the standard recursive algorithm may be implemented as:\nThe short-circuited algorithm may be implemented as:", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nHybrid algorithm\nRecursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is merge sort, which is often implemented by switching to the non-recursive insertion sort when the data is sufficiently small, as in the tiled merge sort. Hybrid recursive algorithms can often be further refined, as in Timsort, derived from a hybrid merge sort/insertion sort.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nHybrid algorithm\nRecursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is merge sort, which is often implemented by switching to the non-recursive insertion sort when the data is sufficiently small, as in the tiled merge sort. Hybrid recursive algorithms can often be further refined, as in Timsort, derived from a hybrid merge sort/insertion sort.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nHybrid algorithm\nRecursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is merge sort, which is often implemented by switching to the non-recursive insertion sort when the data is sufficiently small, as in the tiled merge sort. Hybrid recursive algorithms can often be further refined, as in Timsort, derived from a hybrid merge sort/insertion sort.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nHybrid algorithm\nRecursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is merge sort, which is often implemented by switching to the non-recursive insertion sort when the data is sufficiently small, as in the tiled merge sort. Hybrid recursive algorithms can often be further refined, as in Timsort, derived from a hybrid merge sort/insertion sort.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nImplementation issues\nHybrid algorithm\nRecursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is merge sort, which is often implemented by switching to the non-recursive insertion sort when the data is sufficiently small, as in the tiled merge sort. Hybrid recursive algorithms can often be further refined, as in Timsort, derived from a hybrid merge sort/insertion sort.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRecursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable.\nCompare the templates to compute xn defined by xn = f(n, xn-1) from xbase:\nFor an imperative language the overhead is to define the function, and for a functional language the overhead is to define the accumulator variable x.\nFor example, a factorial function may be implemented iteratively in C by assigning to a loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion:", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRecursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable.\nCompare the templates to compute xn defined by xn = f(n, xn-1) from xbase:\nFor an imperative language the overhead is to define the function, and for a functional language the overhead is to define the accumulator variable x.\nFor example, a factorial function may be implemented iteratively in C by assigning to a loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion:", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRecursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable.\nCompare the templates to compute xn defined by xn = f(n, xn-1) from xbase:\nFor an imperative language the overhead is to define the function, and for a functional language the overhead is to define the accumulator variable x.\nFor example, a factorial function may be implemented iteratively in C by assigning to a loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion:", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRecursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable.\nCompare the templates to compute xn defined by xn = f(n, xn-1) from xbase:\nFor an imperative language the overhead is to define the function, and for a functional language the overhead is to define the accumulator variable x.\nFor example, a factorial function may be implemented iteratively in C by assigning to a loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion:", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRecursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable.\nCompare the templates to compute xn defined by xn = f(n, xn-1) from xbase:\nFor an imperative language the overhead is to define the function, and for a functional language the overhead is to define the accumulator variable x.\nFor example, a factorial function may be implemented iteratively in C by assigning to a loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion:", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nExpressive power\nMost programming languages in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's runtime environment keeps track of the various instances of the function (often using a call stack, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with iterative control constructs and simulating the call stack with a stack explicitly managed by the program.\nConversely, all iterative functions and procedures that can be evaluated by a computer (see Turing completeness) can be expressed in terms of recursive functions; iterative control constructs such as while loops and for loops are routinely rewritten in recursive form in functional languages. However, in practice this rewriting depends on tail call elimination, which is not a feature of all languages. C, Java, and Python are notable mainstream languages in which all function calls, including tail calls, may cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may overflow the call stack, although tail call elimination may be a feature that is not covered by a language's specification, and different implementations of the same language may differ in tail call elimination capabilities.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nExpressive power\nMost programming languages in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's runtime environment keeps track of the various instances of the function (often using a call stack, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with iterative control constructs and simulating the call stack with a stack explicitly managed by the program.\nConversely, all iterative functions and procedures that can be evaluated by a computer (see Turing completeness) can be expressed in terms of recursive functions; iterative control constructs such as while loops and for loops are routinely rewritten in recursive form in functional languages. However, in practice this rewriting depends on tail call elimination, which is not a feature of all languages. C, Java, and Python are notable mainstream languages in which all function calls, including tail calls, may cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may overflow the call stack, although tail call elimination may be a feature that is not covered by a language's specification, and different implementations of the same language may differ in tail call elimination capabilities.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nExpressive power\nMost programming languages in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's runtime environment keeps track of the various instances of the function (often using a call stack, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with iterative control constructs and simulating the call stack with a stack explicitly managed by the program.\nConversely, all iterative functions and procedures that can be evaluated by a computer (see Turing completeness) can be expressed in terms of recursive functions; iterative control constructs such as while loops and for loops are routinely rewritten in recursive form in functional languages. However, in practice this rewriting depends on tail call elimination, which is not a feature of all languages. C, Java, and Python are notable mainstream languages in which all function calls, including tail calls, may cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may overflow the call stack, although tail call elimination may be a feature that is not covered by a language's specification, and different implementations of the same language may differ in tail call elimination capabilities.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nExpressive power\nMost programming languages in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's runtime environment keeps track of the various instances of the function (often using a call stack, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with iterative control constructs and simulating the call stack with a stack explicitly managed by the program.\nConversely, all iterative functions and procedures that can be evaluated by a computer (see Turing completeness) can be expressed in terms of recursive functions; iterative control constructs such as while loops and for loops are routinely rewritten in recursive form in functional languages. However, in practice this rewriting depends on tail call elimination, which is not a feature of all languages. C, Java, and Python are notable mainstream languages in which all function calls, including tail calls, may cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may overflow the call stack, although tail call elimination may be a feature that is not covered by a language's specification, and different implementations of the same language may differ in tail call elimination capabilities.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nExpressive power\nMost programming languages in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's runtime environment keeps track of the various instances of the function (often using a call stack, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with iterative control constructs and simulating the call stack with a stack explicitly managed by the program.\nConversely, all iterative functions and procedures that can be evaluated by a computer (see Turing completeness) can be expressed in terms of recursive functions; iterative control constructs such as while loops and for loops are routinely rewritten in recursive form in functional languages. However, in practice this rewriting depends on tail call elimination, which is not a feature of all languages. C, Java, and Python are notable mainstream languages in which all function calls, including tail calls, may cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may overflow the call stack, although tail call elimination may be a feature that is not covered by a language's specification, and different implementations of the same language may differ in tail call elimination capabilities.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nPerformance issues\nIn languages (such as C and Java) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in functional languages, a function call (particularly a tail call) is typically a very fast operation, and the difference is usually less noticeable.\nAs a concrete example, the difference in performance between recursive and iterative implementations of the \"factorial\" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nPerformance issues\nIn languages (such as C and Java) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in functional languages, a function call (particularly a tail call) is typically a very fast operation, and the difference is usually less noticeable.\nAs a concrete example, the difference in performance between recursive and iterative implementations of the \"factorial\" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nPerformance issues\nIn languages (such as C and Java) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in functional languages, a function call (particularly a tail call) is typically a very fast operation, and the difference is usually less noticeable.\nAs a concrete example, the difference in performance between recursive and iterative implementations of the \"factorial\" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nPerformance issues\nIn languages (such as C and Java) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in functional languages, a function call (particularly a tail call) is typically a very fast operation, and the difference is usually less noticeable.\nAs a concrete example, the difference in performance between recursive and iterative implementations of the \"factorial\" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nPerformance issues\nIn languages (such as C and Java) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in functional languages, a function call (particularly a tail call) is typically a very fast operation, and the difference is usually less noticeable.\nAs a concrete example, the difference in performance between recursive and iterative implementations of the \"factorial\" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nStack space\nIn some programming languages, the maximum size of the call stack is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; Python is one such language. Note the caveat below regarding the special case of tail recursion.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nStack space\nIn some programming languages, the maximum size of the call stack is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; Python is one such language. Note the caveat below regarding the special case of tail recursion.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nStack space\nIn some programming languages, the maximum size of the call stack is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; Python is one such language. Note the caveat below regarding the special case of tail recursion.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nStack space\nIn some programming languages, the maximum size of the call stack is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; Python is one such language. Note the caveat below regarding the special case of tail recursion.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nStack space\nIn some programming languages, the maximum size of the call stack is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; Python is one such language. Note the caveat below regarding the special case of tail recursion.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nVulnerability\nBecause recursive algorithms can be subject to stack overflows, they may be vulnerable to pathological or malicious input. Some malware specifically targets a program's call stack and takes advantage of the stack's inherently recursive nature. Even in the absence of malware, a stack overflow caused by unbounded recursion can be fatal to the program, and exception handling logic may not prevent the corresponding process from being terminated.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nVulnerability\nBecause recursive algorithms can be subject to stack overflows, they may be vulnerable to pathological or malicious input. Some malware specifically targets a program's call stack and takes advantage of the stack's inherently recursive nature. Even in the absence of malware, a stack overflow caused by unbounded recursion can be fatal to the program, and exception handling logic may not prevent the corresponding process from being terminated.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nVulnerability\nBecause recursive algorithms can be subject to stack overflows, they may be vulnerable to pathological or malicious input. Some malware specifically targets a program's call stack and takes advantage of the stack's inherently recursive nature. Even in the absence of malware, a stack overflow caused by unbounded recursion can be fatal to the program, and exception handling logic may not prevent the corresponding process from being terminated.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nVulnerability\nBecause recursive algorithms can be subject to stack overflows, they may be vulnerable to pathological or malicious input. Some malware specifically targets a program's call stack and takes advantage of the stack's inherently recursive nature. Even in the absence of malware, a stack overflow caused by unbounded recursion can be fatal to the program, and exception handling logic may not prevent the corresponding process from being terminated.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nVulnerability\nBecause recursive algorithms can be subject to stack overflows, they may be vulnerable to pathological or malicious input. Some malware specifically targets a program's call stack and takes advantage of the stack's inherently recursive nature. Even in the absence of malware, a stack overflow caused by unbounded recursion can be fatal to the program, and exception handling logic may not prevent the corresponding process from being terminated.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nMultiply recursive problems\nMultiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search; though both recursive and iterative methods are used, they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort, and functions such as the Ackermann function. All of these algorithms can be implemented iteratively with the help of an explicit stack, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nMultiply recursive problems\nMultiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search; though both recursive and iterative methods are used, they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort, and functions such as the Ackermann function. All of these algorithms can be implemented iteratively with the help of an explicit stack, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nMultiply recursive problems\nMultiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search; though both recursive and iterative methods are used, they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort, and functions such as the Ackermann function. All of these algorithms can be implemented iteratively with the help of an explicit stack, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nMultiply recursive problems\nMultiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search; though both recursive and iterative methods are used, they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort, and functions such as the Ackermann function. All of these algorithms can be implemented iteratively with the help of an explicit stack, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nMultiply recursive problems\nMultiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search; though both recursive and iterative methods are used, they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort, and functions such as the Ackermann function. All of these algorithms can be implemented iteratively with the help of an explicit stack, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRefactoring recursion\nRecursive algorithms can be replaced with non-recursive counterparts. One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory. An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging. For example, recursive algorithms for matching wildcards, such as Rich Salz' wildmat algorithm, were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm, have been developed to avoid the drawbacks of recursion and have improved only gradually based on techniques such as collecting tests and profiling performance.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRefactoring recursion\nRecursive algorithms can be replaced with non-recursive counterparts. One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory. An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging. For example, recursive algorithms for matching wildcards, such as Rich Salz' wildmat algorithm, were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm, have been developed to avoid the drawbacks of recursion and have improved only gradually based on techniques such as collecting tests and profiling performance.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRefactoring recursion\nRecursive algorithms can be replaced with non-recursive counterparts. One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory. An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging. For example, recursive algorithms for matching wildcards, such as Rich Salz' wildmat algorithm, were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm, have been developed to avoid the drawbacks of recursion and have improved only gradually based on techniques such as collecting tests and profiling performance.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRefactoring recursion\nRecursive algorithms can be replaced with non-recursive counterparts. One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory. An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging. For example, recursive algorithms for matching wildcards, such as Rich Salz' wildmat algorithm, were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm, have been developed to avoid the drawbacks of recursion and have improved only gradually based on techniques such as collecting tests and profiling performance.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion versus iteration\nRefactoring recursion\nRecursive algorithms can be replaced with non-recursive counterparts. One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory. An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging. For example, recursive algorithms for matching wildcards, such as Rich Salz' wildmat algorithm, were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm, have been developed to avoid the drawbacks of recursion and have improved only gradually based on techniques such as collecting tests and profiling performance.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTail-recursive functions\nTail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive.  In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes.  With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls, a tail-recursive function such as gcd will execute using constant space.  Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops.\nThe significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTail-recursive functions\nTail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive.  In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes.  With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls, a tail-recursive function such as gcd will execute using constant space.  Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops.\nThe significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTail-recursive functions\nTail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive.  In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes.  With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls, a tail-recursive function such as gcd will execute using constant space.  Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops.\nThe significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTail-recursive functions\nTail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive.  In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes.  With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls, a tail-recursive function such as gcd will execute using constant space.  Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops.\nThe significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTail-recursive functions\nTail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive.  In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes.  With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls, a tail-recursive function such as gcd will execute using constant space.  Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops.\nThe significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nConsider these two functions:", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nConsider these two functions:", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nConsider these two functions:", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nConsider these two functions:", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nConsider these two functions:", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nFunction 2\nThe output of function 2 is that of function 1 with the lines swapped.\nIn the case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached.\nAlso note that the order of the print statements is reversed, which is due to the way the functions and statements are stored on the call stack.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nFunction 2\nThe output of function 2 is that of function 1 with the lines swapped.\nIn the case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached.\nAlso note that the order of the print statements is reversed, which is due to the way the functions and statements are stored on the call stack.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nFunction 2\nThe output of function 2 is that of function 1 with the lines swapped.\nIn the case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached.\nAlso note that the order of the print statements is reversed, which is due to the way the functions and statements are stored on the call stack.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nFunction 2\nThe output of function 2 is that of function 1 with the lines swapped.\nIn the case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached.\nAlso note that the order of the print statements is reversed, which is due to the way the functions and statements are stored on the call stack.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nOrder of execution\nFunction 2\nThe output of function 2 is that of function 1 with the lines swapped.\nIn the case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached.\nAlso note that the order of the print statements is reversed, which is due to the way the functions and statements are stored on the call stack.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nA classic example of a recursive procedure is the function used to calculate the factorial of a natural number:\n```\nfact\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              0\n            \n          \n          \n            \n              n\n              ⋅\n              fact\n              ⁡\n              (\n              n\n              −\n              1\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {fact} (n)={\\begin{cases}1&{\\mbox{if }}n=0\\\\n\\cdot \\operatorname {fact} (n-1)&{\\mbox{if }}n>0\\\\\\end{cases}}}\n```\nThe function can also be written as a recurrence relation:\n```\nb\n      \n        n\n      \n    \n    =\n    n\n    \n      b\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle b_{n}=nb_{n-1}}\n\n\n\n\n  \n    \n      b\n      \n        0\n      \n    \n    =\n    1\n  \n\n{\\displaystyle b_{0}=1}\n```\nThis evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:\nThis factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:\nThe imperative code above is equivalent to this mathematical definition using an accumulator variable t:", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nA classic example of a recursive procedure is the function used to calculate the factorial of a natural number:\n```\nfact\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              0\n            \n          \n          \n            \n              n\n              ⋅\n              fact\n              ⁡\n              (\n              n\n              −\n              1\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {fact} (n)={\\begin{cases}1&{\\mbox{if }}n=0\\\\n\\cdot \\operatorname {fact} (n-1)&{\\mbox{if }}n>0\\\\\\end{cases}}}\n```\nThe function can also be written as a recurrence relation:\n```\nb\n      \n        n\n      \n    \n    =\n    n\n    \n      b\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle b_{n}=nb_{n-1}}\n\n\n\n\n  \n    \n      b\n      \n        0\n      \n    \n    =\n    1\n  \n\n{\\displaystyle b_{0}=1}\n```\nThis evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:\nThis factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:\nThe imperative code above is equivalent to this mathematical definition using an accumulator variable t:", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nA classic example of a recursive procedure is the function used to calculate the factorial of a natural number:\n```\nfact\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              0\n            \n          \n          \n            \n              n\n              ⋅\n              fact\n              ⁡\n              (\n              n\n              −\n              1\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {fact} (n)={\\begin{cases}1&{\\mbox{if }}n=0\\\\n\\cdot \\operatorname {fact} (n-1)&{\\mbox{if }}n>0\\\\\\end{cases}}}\n```\nThe function can also be written as a recurrence relation:\n```\nb\n      \n        n\n      \n    \n    =\n    n\n    \n      b\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle b_{n}=nb_{n-1}}\n\n\n\n\n  \n    \n      b\n      \n        0\n      \n    \n    =\n    1\n  \n\n{\\displaystyle b_{0}=1}\n```\nThis evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:\nThis factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:\nThe imperative code above is equivalent to this mathematical definition using an accumulator variable t:", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nA classic example of a recursive procedure is the function used to calculate the factorial of a natural number:\n```\nfact\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              0\n            \n          \n          \n            \n              n\n              ⋅\n              fact\n              ⁡\n              (\n              n\n              −\n              1\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {fact} (n)={\\begin{cases}1&{\\mbox{if }}n=0\\\\n\\cdot \\operatorname {fact} (n-1)&{\\mbox{if }}n>0\\\\\\end{cases}}}\n```\nThe function can also be written as a recurrence relation:\n```\nb\n      \n        n\n      \n    \n    =\n    n\n    \n      b\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle b_{n}=nb_{n-1}}\n\n\n\n\n  \n    \n      b\n      \n        0\n      \n    \n    =\n    1\n  \n\n{\\displaystyle b_{0}=1}\n```\nThis evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:\nThis factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:\nThe imperative code above is equivalent to this mathematical definition using an accumulator variable t:", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nA classic example of a recursive procedure is the function used to calculate the factorial of a natural number:\n```\nfact\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              0\n            \n          \n          \n            \n              n\n              ⋅\n              fact\n              ⁡\n              (\n              n\n              −\n              1\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {fact} (n)={\\begin{cases}1&{\\mbox{if }}n=0\\\\n\\cdot \\operatorname {fact} (n-1)&{\\mbox{if }}n>0\\\\\\end{cases}}}\n```\nThe function can also be written as a recurrence relation:\n```\nb\n      \n        n\n      \n    \n    =\n    n\n    \n      b\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle b_{n}=nb_{n-1}}\n\n\n\n\n  \n    \n      b\n      \n        0\n      \n    \n    =\n    1\n  \n\n{\\displaystyle b_{0}=1}\n```\nThis evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:\nThis factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:\nThe imperative code above is equivalent to this mathematical definition using an accumulator variable t:", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\n```\nfact\n            ⁡\n            (\n            n\n            )\n          \n          \n            \n            =\n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            1\n            )\n          \n        \n        \n          \n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            t\n            )\n          \n          \n            \n            =\n            \n              \n                {\n                \n                  \n                    \n                      t\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      =\n                      0\n                    \n                  \n                  \n                    \n                      \n                        f\n                        a\n                        c\n                        \n                          t\n                          \n                            a\n                            c\n                            c\n                          \n                        \n                      \n                      ⁡\n                      (\n                      n\n                      −\n                      1\n                      ,\n                      n\n                      t\n                      )\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      >\n                      0\n                    \n                  \n                \n                \n              \n            \n          \n        \n      \n    \n  \n\n{\\displaystyle {\\begin{aligned}\\operatorname {fact} (n)&=\\operatorname {fact_{acc}} (n,1)\\\\\\operatorname {fact_{acc}} (n,t)&={\\begin{cases}t&{\\mbox{if }}n=0\\\\\\operatorname {fact_{acc}} (n-1,nt)&{\\mbox{if }}n>0\\\\\\end{cases}}\\end{aligned}}}\n```", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\n```\nfact\n            ⁡\n            (\n            n\n            )\n          \n          \n            \n            =\n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            1\n            )\n          \n        \n        \n          \n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            t\n            )\n          \n          \n            \n            =\n            \n              \n                {\n                \n                  \n                    \n                      t\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      =\n                      0\n                    \n                  \n                  \n                    \n                      \n                        f\n                        a\n                        c\n                        \n                          t\n                          \n                            a\n                            c\n                            c\n                          \n                        \n                      \n                      ⁡\n                      (\n                      n\n                      −\n                      1\n                      ,\n                      n\n                      t\n                      )\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      >\n                      0\n                    \n                  \n                \n                \n              \n            \n          \n        \n      \n    \n  \n\n{\\displaystyle {\\begin{aligned}\\operatorname {fact} (n)&=\\operatorname {fact_{acc}} (n,1)\\\\\\operatorname {fact_{acc}} (n,t)&={\\begin{cases}t&{\\mbox{if }}n=0\\\\\\operatorname {fact_{acc}} (n-1,nt)&{\\mbox{if }}n>0\\\\\\end{cases}}\\end{aligned}}}\n```", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\n```\nfact\n            ⁡\n            (\n            n\n            )\n          \n          \n            \n            =\n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            1\n            )\n          \n        \n        \n          \n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            t\n            )\n          \n          \n            \n            =\n            \n              \n                {\n                \n                  \n                    \n                      t\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      =\n                      0\n                    \n                  \n                  \n                    \n                      \n                        f\n                        a\n                        c\n                        \n                          t\n                          \n                            a\n                            c\n                            c\n                          \n                        \n                      \n                      ⁡\n                      (\n                      n\n                      −\n                      1\n                      ,\n                      n\n                      t\n                      )\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      >\n                      0\n                    \n                  \n                \n                \n              \n            \n          \n        \n      \n    \n  \n\n{\\displaystyle {\\begin{aligned}\\operatorname {fact} (n)&=\\operatorname {fact_{acc}} (n,1)\\\\\\operatorname {fact_{acc}} (n,t)&={\\begin{cases}t&{\\mbox{if }}n=0\\\\\\operatorname {fact_{acc}} (n-1,nt)&{\\mbox{if }}n>0\\\\\\end{cases}}\\end{aligned}}}\n```", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\n```\nfact\n            ⁡\n            (\n            n\n            )\n          \n          \n            \n            =\n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            1\n            )\n          \n        \n        \n          \n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            t\n            )\n          \n          \n            \n            =\n            \n              \n                {\n                \n                  \n                    \n                      t\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      =\n                      0\n                    \n                  \n                  \n                    \n                      \n                        f\n                        a\n                        c\n                        \n                          t\n                          \n                            a\n                            c\n                            c\n                          \n                        \n                      \n                      ⁡\n                      (\n                      n\n                      −\n                      1\n                      ,\n                      n\n                      t\n                      )\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      >\n                      0\n                    \n                  \n                \n                \n              \n            \n          \n        \n      \n    \n  \n\n{\\displaystyle {\\begin{aligned}\\operatorname {fact} (n)&=\\operatorname {fact_{acc}} (n,1)\\\\\\operatorname {fact_{acc}} (n,t)&={\\begin{cases}t&{\\mbox{if }}n=0\\\\\\operatorname {fact_{acc}} (n-1,nt)&{\\mbox{if }}n>0\\\\\\end{cases}}\\end{aligned}}}\n```", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\n```\nfact\n            ⁡\n            (\n            n\n            )\n          \n          \n            \n            =\n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            1\n            )\n          \n        \n        \n          \n            \n              f\n              a\n              c\n              \n                t\n                \n                  a\n                  c\n                  c\n                \n              \n            \n            ⁡\n            (\n            n\n            ,\n            t\n            )\n          \n          \n            \n            =\n            \n              \n                {\n                \n                  \n                    \n                      t\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      =\n                      0\n                    \n                  \n                  \n                    \n                      \n                        f\n                        a\n                        c\n                        \n                          t\n                          \n                            a\n                            c\n                            c\n                          \n                        \n                      \n                      ⁡\n                      (\n                      n\n                      −\n                      1\n                      ,\n                      n\n                      t\n                      )\n                    \n                    \n                      \n                        \n                          if \n                        \n                      \n                      n\n                      >\n                      0\n                    \n                  \n                \n                \n              \n            \n          \n        \n      \n    \n  \n\n{\\displaystyle {\\begin{aligned}\\operatorname {fact} (n)&=\\operatorname {fact_{acc}} (n,1)\\\\\\operatorname {fact_{acc}} (n,t)&={\\begin{cases}t&{\\mbox{if }}n=0\\\\\\operatorname {fact_{acc}} (n-1,nt)&{\\mbox{if }}n>0\\\\\\end{cases}}\\end{aligned}}}\n```", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nThe definition above translates straightforwardly to functional programming languages such as Scheme; this is an example of iteration implemented recursively.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nThe definition above translates straightforwardly to functional programming languages such as Scheme; this is an example of iteration implemented recursively.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nThe definition above translates straightforwardly to functional programming languages such as Scheme; this is an example of iteration implemented recursively.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nThe definition above translates straightforwardly to functional programming languages such as Scheme; this is an example of iteration implemented recursively.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nFactorial\nThe definition above translates straightforwardly to functional programming languages such as Scheme; this is an example of iteration implemented recursively.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe Euclidean algorithm, which computes the greatest common divisor of two integers, can be written recursively.\nFunction definition:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              x\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              =\n              0\n            \n          \n          \n            \n              gcd\n              (\n              y\n              ,\n              remainder\n              ⁡\n              (\n              x\n              ,\n              y\n              )\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\\\end{cases}}}\n```\nRecurrence relation for greatest common divisor, where\n```\nx\n    %\n    y\n  \n\n{\\displaystyle x\\%y}\n```\nexpresses the remainder of\n```\nx\n    \n      /\n    \n    y\n  \n\n{\\displaystyle x/y}\n```\n:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    gcd\n    (\n    y\n    ,\n    x\n    %\n    y\n    )\n  \n\n{\\displaystyle \\gcd(x,y)=\\gcd(y,x\\%y)}\n```\nif\n```\ny\n    ≠\n    0\n  \n\n{\\displaystyle y\\neq 0}\n\n\n\n\n  \n    gcd\n    (\n    x\n    ,\n    0\n    )\n    =\n    x\n  \n\n{\\displaystyle \\gcd(x,0)=x}\n```", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe Euclidean algorithm, which computes the greatest common divisor of two integers, can be written recursively.\nFunction definition:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              x\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              =\n              0\n            \n          \n          \n            \n              gcd\n              (\n              y\n              ,\n              remainder\n              ⁡\n              (\n              x\n              ,\n              y\n              )\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\\\end{cases}}}\n```\nRecurrence relation for greatest common divisor, where\n```\nx\n    %\n    y\n  \n\n{\\displaystyle x\\%y}\n```\nexpresses the remainder of\n```\nx\n    \n      /\n    \n    y\n  \n\n{\\displaystyle x/y}\n```\n:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    gcd\n    (\n    y\n    ,\n    x\n    %\n    y\n    )\n  \n\n{\\displaystyle \\gcd(x,y)=\\gcd(y,x\\%y)}\n```\nif\n```\ny\n    ≠\n    0\n  \n\n{\\displaystyle y\\neq 0}\n\n\n\n\n  \n    gcd\n    (\n    x\n    ,\n    0\n    )\n    =\n    x\n  \n\n{\\displaystyle \\gcd(x,0)=x}\n```", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe Euclidean algorithm, which computes the greatest common divisor of two integers, can be written recursively.\nFunction definition:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              x\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              =\n              0\n            \n          \n          \n            \n              gcd\n              (\n              y\n              ,\n              remainder\n              ⁡\n              (\n              x\n              ,\n              y\n              )\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\\\end{cases}}}\n```\nRecurrence relation for greatest common divisor, where\n```\nx\n    %\n    y\n  \n\n{\\displaystyle x\\%y}\n```\nexpresses the remainder of\n```\nx\n    \n      /\n    \n    y\n  \n\n{\\displaystyle x/y}\n```\n:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    gcd\n    (\n    y\n    ,\n    x\n    %\n    y\n    )\n  \n\n{\\displaystyle \\gcd(x,y)=\\gcd(y,x\\%y)}\n```\nif\n```\ny\n    ≠\n    0\n  \n\n{\\displaystyle y\\neq 0}\n\n\n\n\n  \n    gcd\n    (\n    x\n    ,\n    0\n    )\n    =\n    x\n  \n\n{\\displaystyle \\gcd(x,0)=x}\n```", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe Euclidean algorithm, which computes the greatest common divisor of two integers, can be written recursively.\nFunction definition:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              x\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              =\n              0\n            \n          \n          \n            \n              gcd\n              (\n              y\n              ,\n              remainder\n              ⁡\n              (\n              x\n              ,\n              y\n              )\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\\\end{cases}}}\n```\nRecurrence relation for greatest common divisor, where\n```\nx\n    %\n    y\n  \n\n{\\displaystyle x\\%y}\n```\nexpresses the remainder of\n```\nx\n    \n      /\n    \n    y\n  \n\n{\\displaystyle x/y}\n```\n:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    gcd\n    (\n    y\n    ,\n    x\n    %\n    y\n    )\n  \n\n{\\displaystyle \\gcd(x,y)=\\gcd(y,x\\%y)}\n```\nif\n```\ny\n    ≠\n    0\n  \n\n{\\displaystyle y\\neq 0}\n\n\n\n\n  \n    gcd\n    (\n    x\n    ,\n    0\n    )\n    =\n    x\n  \n\n{\\displaystyle \\gcd(x,0)=x}\n```", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe Euclidean algorithm, which computes the greatest common divisor of two integers, can be written recursively.\nFunction definition:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              x\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              =\n              0\n            \n          \n          \n            \n              gcd\n              (\n              y\n              ,\n              remainder\n              ⁡\n              (\n              x\n              ,\n              y\n              )\n              )\n            \n            \n              \n                \n                  if \n                \n              \n              y\n              >\n              0\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\\\end{cases}}}\n```\nRecurrence relation for greatest common divisor, where\n```\nx\n    %\n    y\n  \n\n{\\displaystyle x\\%y}\n```\nexpresses the remainder of\n```\nx\n    \n      /\n    \n    y\n  \n\n{\\displaystyle x/y}\n```\n:\n```\ngcd\n    (\n    x\n    ,\n    y\n    )\n    =\n    gcd\n    (\n    y\n    ,\n    x\n    %\n    y\n    )\n  \n\n{\\displaystyle \\gcd(x,y)=\\gcd(y,x\\%y)}\n```\nif\n```\ny\n    ≠\n    0\n  \n\n{\\displaystyle y\\neq 0}\n\n\n\n\n  \n    gcd\n    (\n    x\n    ,\n    0\n    )\n    =\n    x\n  \n\n{\\displaystyle \\gcd(x,0)=x}\n```", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe recursive program above is tail-recursive; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls.  Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls.  By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.\nThe iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe recursive program above is tail-recursive; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls.  Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls.  By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.\nThe iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe recursive program above is tail-recursive; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls.  Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls.  By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.\nThe iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe recursive program above is tail-recursive; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls.  Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls.  By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.\nThe iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nGreatest common divisor\nThe recursive program above is tail-recursive; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls.  Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls.  By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack.\nThe iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nTowers of Hanoi\nThe Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion. There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?\nFunction definition:\n```\nhanoi\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              1\n            \n          \n          \n            \n              2\n              ⋅\n              hanoi\n              ⁡\n              (\n              n\n              −\n              1\n              )\n              +\n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              1\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\\\end{cases}}}\n```\nRecurrence relation for hanoi:\n```\nh\n      \n        n\n      \n    \n    =\n    2\n    \n      h\n      \n        n\n        −\n        1\n      \n    \n    +\n    1\n  \n\n{\\displaystyle h_{n}=2h_{n-1}+1}\n\n\n\n\n  \n    \n      h\n      \n        1\n      \n    \n    =\n    1\n  \n\n{\\displaystyle h_{1}=1}\n```\nExample implementations:\nAlthough not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nTowers of Hanoi\nThe Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion. There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?\nFunction definition:\n```\nhanoi\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              1\n            \n          \n          \n            \n              2\n              ⋅\n              hanoi\n              ⁡\n              (\n              n\n              −\n              1\n              )\n              +\n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              1\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\\\end{cases}}}\n```\nRecurrence relation for hanoi:\n```\nh\n      \n        n\n      \n    \n    =\n    2\n    \n      h\n      \n        n\n        −\n        1\n      \n    \n    +\n    1\n  \n\n{\\displaystyle h_{n}=2h_{n-1}+1}\n\n\n\n\n  \n    \n      h\n      \n        1\n      \n    \n    =\n    1\n  \n\n{\\displaystyle h_{1}=1}\n```\nExample implementations:\nAlthough not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nTowers of Hanoi\nThe Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion. There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?\nFunction definition:\n```\nhanoi\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              1\n            \n          \n          \n            \n              2\n              ⋅\n              hanoi\n              ⁡\n              (\n              n\n              −\n              1\n              )\n              +\n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              1\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\\\end{cases}}}\n```\nRecurrence relation for hanoi:\n```\nh\n      \n        n\n      \n    \n    =\n    2\n    \n      h\n      \n        n\n        −\n        1\n      \n    \n    +\n    1\n  \n\n{\\displaystyle h_{n}=2h_{n-1}+1}\n\n\n\n\n  \n    \n      h\n      \n        1\n      \n    \n    =\n    1\n  \n\n{\\displaystyle h_{1}=1}\n```\nExample implementations:\nAlthough not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nTowers of Hanoi\nThe Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion. There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?\nFunction definition:\n```\nhanoi\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              1\n            \n          \n          \n            \n              2\n              ⋅\n              hanoi\n              ⁡\n              (\n              n\n              −\n              1\n              )\n              +\n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              1\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\\\end{cases}}}\n```\nRecurrence relation for hanoi:\n```\nh\n      \n        n\n      \n    \n    =\n    2\n    \n      h\n      \n        n\n        −\n        1\n      \n    \n    +\n    1\n  \n\n{\\displaystyle h_{n}=2h_{n-1}+1}\n\n\n\n\n  \n    \n      h\n      \n        1\n      \n    \n    =\n    1\n  \n\n{\\displaystyle h_{1}=1}\n```\nExample implementations:\nAlthough not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nTowers of Hanoi\nThe Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion. There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?\nFunction definition:\n```\nhanoi\n    ⁡\n    (\n    n\n    )\n    =\n    \n      \n        {\n        \n          \n            \n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              =\n              1\n            \n          \n          \n            \n              2\n              ⋅\n              hanoi\n              ⁡\n              (\n              n\n              −\n              1\n              )\n              +\n              1\n            \n            \n              \n                \n                  if \n                \n              \n              n\n              >\n              1\n            \n          \n        \n        \n      \n    \n  \n\n{\\displaystyle \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\\\end{cases}}}\n```\nRecurrence relation for hanoi:\n```\nh\n      \n        n\n      \n    \n    =\n    2\n    \n      h\n      \n        n\n        −\n        1\n      \n    \n    +\n    1\n  \n\n{\\displaystyle h_{n}=2h_{n-1}+1}\n\n\n\n\n  \n    \n      h\n      \n        1\n      \n    \n    =\n    1\n  \n\n{\\displaystyle h_{1}=1}\n```\nExample implementations:\nAlthough not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nBinary search\nThe binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.\nRecursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.\nExample implementation of binary search in C:", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nBinary search\nThe binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.\nRecursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.\nExample implementation of binary search in C:", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nBinary search\nThe binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.\nRecursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.\nExample implementation of binary search in C:", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nBinary search\nThe binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.\nRecursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.\nExample implementation of binary search in C:", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive procedures\nBinary search\nThe binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.\nRecursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.\nExample implementation of binary search in C:", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nAn important application of recursion in computer science is in defining dynamic data structures such as lists and trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.\n\"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"\nThe examples in this section illustrate what is known as \"structural recursion\".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.\nAs long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nAn important application of recursion in computer science is in defining dynamic data structures such as lists and trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.\n\"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"\nThe examples in this section illustrate what is known as \"structural recursion\".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.\nAs long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nAn important application of recursion in computer science is in defining dynamic data structures such as lists and trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.\n\"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"\nThe examples in this section illustrate what is known as \"structural recursion\".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.\nAs long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nAn important application of recursion in computer science is in defining dynamic data structures such as lists and trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.\n\"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"\nThe examples in this section illustrate what is known as \"structural recursion\".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.\nAs long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nAn important application of recursion in computer science is in defining dynamic data structures such as lists and trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.\n\"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"\nThe examples in this section illustrate what is known as \"structural recursion\".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.\nAs long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nLinked lists\nBelow is a C definition of a linked list node structure.  Notice especially how the node is defined in terms of itself.  The \"next\" element of struct node is a pointer to another struct node, effectively creating a list type.\nBecause the struct node data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures.  The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL).  For each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the list_print procedure.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nLinked lists\nBelow is a C definition of a linked list node structure.  Notice especially how the node is defined in terms of itself.  The \"next\" element of struct node is a pointer to another struct node, effectively creating a list type.\nBecause the struct node data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures.  The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL).  For each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the list_print procedure.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nLinked lists\nBelow is a C definition of a linked list node structure.  Notice especially how the node is defined in terms of itself.  The \"next\" element of struct node is a pointer to another struct node, effectively creating a list type.\nBecause the struct node data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures.  The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL).  For each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the list_print procedure.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nLinked lists\nBelow is a C definition of a linked list node structure.  Notice especially how the node is defined in terms of itself.  The \"next\" element of struct node is a pointer to another struct node, effectively creating a list type.\nBecause the struct node data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures.  The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL).  For each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the list_print procedure.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nLinked lists\nBelow is a C definition of a linked list node structure.  Notice especially how the node is defined in terms of itself.  The \"next\" element of struct node is a pointer to another struct node, effectively creating a list type.\nBecause the struct node data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures.  The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL).  For each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the list_print procedure.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nBinary trees\nBelow is a simple definition for a binary tree node.  Like the node for linked lists, it is defined in terms of itself, recursively.  There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).\nOperations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:\nAt most two recursive calls will be made for any given call to tree_contains as defined above.\nThe above example illustrates an in-order traversal of the binary tree.  A Binary search tree is a special case of the binary tree where the data elements of each node are in order.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nBinary trees\nBelow is a simple definition for a binary tree node.  Like the node for linked lists, it is defined in terms of itself, recursively.  There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).\nOperations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:\nAt most two recursive calls will be made for any given call to tree_contains as defined above.\nThe above example illustrates an in-order traversal of the binary tree.  A Binary search tree is a special case of the binary tree where the data elements of each node are in order.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nBinary trees\nBelow is a simple definition for a binary tree node.  Like the node for linked lists, it is defined in terms of itself, recursively.  There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).\nOperations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:\nAt most two recursive calls will be made for any given call to tree_contains as defined above.\nThe above example illustrates an in-order traversal of the binary tree.  A Binary search tree is a special case of the binary tree where the data elements of each node are in order.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nBinary trees\nBelow is a simple definition for a binary tree node.  Like the node for linked lists, it is defined in terms of itself, recursively.  There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).\nOperations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:\nAt most two recursive calls will be made for any given call to tree_contains as defined above.\nThe above example illustrates an in-order traversal of the binary tree.  A Binary search tree is a special case of the binary tree where the data elements of each node are in order.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nBinary trees\nBelow is a simple definition for a binary tree node.  Like the node for linked lists, it is defined in terms of itself, recursively.  There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).\nOperations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:\nAt most two recursive calls will be made for any given call to tree_contains as defined above.\nThe above example illustrates an in-order traversal of the binary tree.  A Binary search tree is a special case of the binary tree where the data elements of each node are in order.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nFilesystem traversal\nSince the number of files in a filesystem may vary, recursion is the only practical way to traverse and thus enumerate its contents.  Traversing a filesystem is very similar to that of tree traversal, therefore the concepts behind tree traversal are applicable to traversing a filesystem.  More specifically, the code below would be an example of a preorder traversal of a filesystem.\nThis code is both recursion and iteration - the files and directories are iterated, and each directory is opened recursively.\nThe \"rtraverse\" method is an example of direct recursion, whilst the \"traverse\" method is a wrapper function.\nThe \"base case\" scenario is that there will always be a fixed number of files and/or directories in a given filesystem.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nFilesystem traversal\nSince the number of files in a filesystem may vary, recursion is the only practical way to traverse and thus enumerate its contents.  Traversing a filesystem is very similar to that of tree traversal, therefore the concepts behind tree traversal are applicable to traversing a filesystem.  More specifically, the code below would be an example of a preorder traversal of a filesystem.\nThis code is both recursion and iteration - the files and directories are iterated, and each directory is opened recursively.\nThe \"rtraverse\" method is an example of direct recursion, whilst the \"traverse\" method is a wrapper function.\nThe \"base case\" scenario is that there will always be a fixed number of files and/or directories in a given filesystem.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nFilesystem traversal\nSince the number of files in a filesystem may vary, recursion is the only practical way to traverse and thus enumerate its contents.  Traversing a filesystem is very similar to that of tree traversal, therefore the concepts behind tree traversal are applicable to traversing a filesystem.  More specifically, the code below would be an example of a preorder traversal of a filesystem.\nThis code is both recursion and iteration - the files and directories are iterated, and each directory is opened recursively.\nThe \"rtraverse\" method is an example of direct recursion, whilst the \"traverse\" method is a wrapper function.\nThe \"base case\" scenario is that there will always be a fixed number of files and/or directories in a given filesystem.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nFilesystem traversal\nSince the number of files in a filesystem may vary, recursion is the only practical way to traverse and thus enumerate its contents.  Traversing a filesystem is very similar to that of tree traversal, therefore the concepts behind tree traversal are applicable to traversing a filesystem.  More specifically, the code below would be an example of a preorder traversal of a filesystem.\nThis code is both recursion and iteration - the files and directories are iterated, and each directory is opened recursively.\nThe \"rtraverse\" method is an example of direct recursion, whilst the \"traverse\" method is a wrapper function.\nThe \"base case\" scenario is that there will always be a fixed number of files and/or directories in a given filesystem.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursive data structures (structural recursion)\nFilesystem traversal\nSince the number of files in a filesystem may vary, recursion is the only practical way to traverse and thus enumerate its contents.  Traversing a filesystem is very similar to that of tree traversal, therefore the concepts behind tree traversal are applicable to traversing a filesystem.  More specifically, the code below would be an example of a preorder traversal of a filesystem.\nThis code is both recursion and iteration - the files and directories are iterated, and each directory is opened recursively.\nThe \"rtraverse\" method is an example of direct recursion, whilst the \"traverse\" method is a wrapper function.\nThe \"base case\" scenario is that there will always be a fixed number of files and/or directories in a given filesystem.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nThe time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation.  They can (usually) then be simplified into a single Big-O term.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nThe time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation.  They can (usually) then be simplified into a single Big-O term.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nThe time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation.  They can (usually) then be simplified into a single Big-O term.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nThe time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation.  They can (usually) then be simplified into a single Big-O term.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nThe time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation.  They can (usually) then be simplified into a single Big-O term.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\nIf the time-complexity of the function is in the form\n```\nT\n    (\n    n\n    )\n    =\n    a\n    ⋅\n    T\n    (\n    n\n    \n      /\n    \n    b\n    )\n    +\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)=a\\cdot T(n/b)+f(n)}\n```\nThen the Big O of the time-complexity is thus:\nIf\n```\nf\n    (\n    n\n    )\n    =\n    O\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        −\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=O(n^{\\log _{b}a-\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a})}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Theta (n^{\\log _{b}a})}\n```\n, then", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\nIf the time-complexity of the function is in the form\n```\nT\n    (\n    n\n    )\n    =\n    a\n    ⋅\n    T\n    (\n    n\n    \n      /\n    \n    b\n    )\n    +\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)=a\\cdot T(n/b)+f(n)}\n```\nThen the Big O of the time-complexity is thus:\nIf\n```\nf\n    (\n    n\n    )\n    =\n    O\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        −\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=O(n^{\\log _{b}a-\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a})}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Theta (n^{\\log _{b}a})}\n```\n, then", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\nIf the time-complexity of the function is in the form\n```\nT\n    (\n    n\n    )\n    =\n    a\n    ⋅\n    T\n    (\n    n\n    \n      /\n    \n    b\n    )\n    +\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)=a\\cdot T(n/b)+f(n)}\n```\nThen the Big O of the time-complexity is thus:\nIf\n```\nf\n    (\n    n\n    )\n    =\n    O\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        −\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=O(n^{\\log _{b}a-\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a})}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Theta (n^{\\log _{b}a})}\n```\n, then", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\nIf the time-complexity of the function is in the form\n```\nT\n    (\n    n\n    )\n    =\n    a\n    ⋅\n    T\n    (\n    n\n    \n      /\n    \n    b\n    )\n    +\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)=a\\cdot T(n/b)+f(n)}\n```\nThen the Big O of the time-complexity is thus:\nIf\n```\nf\n    (\n    n\n    )\n    =\n    O\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        −\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=O(n^{\\log _{b}a-\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a})}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Theta (n^{\\log _{b}a})}\n```\n, then", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\nIf the time-complexity of the function is in the form\n```\nT\n    (\n    n\n    )\n    =\n    a\n    ⋅\n    T\n    (\n    n\n    \n      /\n    \n    b\n    )\n    +\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)=a\\cdot T(n/b)+f(n)}\n```\nThen the Big O of the time-complexity is thus:\nIf\n```\nf\n    (\n    n\n    )\n    =\n    O\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        −\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=O(n^{\\log _{b}a-\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a})}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Theta (n^{\\log _{b}a})}\n```\n, then", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a}\\log n)}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Ω\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        +\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Omega (n^{\\log _{b}a+\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, and if\n```\na\n    ⋅\n    f\n    (\n    n\n    \n      /\n    \n    b\n    )\n    ≤\n    c\n    ⋅\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle a\\cdot f(n/b)\\leq c\\cdot f(n)}\n```\nfor some constant c < 1 and all sufficiently large n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    f\n    (\n    n\n    )\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (f(n))}\n```\nwhere a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f(n) represents the work that the function does independently of any recursion (e.g. partitioning, recombining) at each level of recursion.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a}\\log n)}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Ω\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        +\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Omega (n^{\\log _{b}a+\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, and if\n```\na\n    ⋅\n    f\n    (\n    n\n    \n      /\n    \n    b\n    )\n    ≤\n    c\n    ⋅\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle a\\cdot f(n/b)\\leq c\\cdot f(n)}\n```\nfor some constant c < 1 and all sufficiently large n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    f\n    (\n    n\n    )\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (f(n))}\n```\nwhere a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f(n) represents the work that the function does independently of any recursion (e.g. partitioning, recombining) at each level of recursion.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a}\\log n)}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Ω\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        +\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Omega (n^{\\log _{b}a+\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, and if\n```\na\n    ⋅\n    f\n    (\n    n\n    \n      /\n    \n    b\n    )\n    ≤\n    c\n    ⋅\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle a\\cdot f(n/b)\\leq c\\cdot f(n)}\n```\nfor some constant c < 1 and all sufficiently large n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    f\n    (\n    n\n    )\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (f(n))}\n```\nwhere a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f(n) represents the work that the function does independently of any recursion (e.g. partitioning, recombining) at each level of recursion.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a}\\log n)}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Ω\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        +\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Omega (n^{\\log _{b}a+\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, and if\n```\na\n    ⋅\n    f\n    (\n    n\n    \n      /\n    \n    b\n    )\n    ≤\n    c\n    ⋅\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle a\\cdot f(n/b)\\leq c\\cdot f(n)}\n```\nfor some constant c < 1 and all sufficiently large n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    f\n    (\n    n\n    )\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (f(n))}\n```\nwhere a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f(n) represents the work that the function does independently of any recursion (e.g. partitioning, recombining) at each level of recursion.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nTime-efficiency of recursive algorithms\nShortcut rule (master theorem)\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n      \n    \n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (n^{\\log _{b}a}\\log n)}\n```\nIf\n```\nf\n    (\n    n\n    )\n    =\n    Ω\n    (\n    \n      n\n      \n        \n          log\n          \n            b\n          \n        \n        ⁡\n        a\n        +\n        ε\n      \n    \n    )\n  \n\n{\\displaystyle f(n)=\\Omega (n^{\\log _{b}a+\\varepsilon })}\n```\nfor some constant\n```\nε\n    >\n    0\n  \n\n{\\displaystyle \\varepsilon >0}\n```\n, and if\n```\na\n    ⋅\n    f\n    (\n    n\n    \n      /\n    \n    b\n    )\n    ≤\n    c\n    ⋅\n    f\n    (\n    n\n    )\n  \n\n{\\displaystyle a\\cdot f(n/b)\\leq c\\cdot f(n)}\n```\nfor some constant c < 1 and all sufficiently large n, then\n```\nT\n    (\n    n\n    )\n    =\n    Θ\n    (\n    f\n    (\n    n\n    )\n    )\n  \n\n{\\displaystyle T(n)=\\Theta (f(n))}\n```\nwhere a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f(n) represents the work that the function does independently of any recursion (e.g. partitioning, recombining) at each level of recursion.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nIn the procedural interpretation of logic programs, clauses (or rules) of the form A :- B are treated as procedures, which reduce goals of the form A to subgoals of the form B.\nFor example, the Prolog clauses:\ndefine a  procedure, which can be used to search for a path from  X to  Y, either by finding a direct arc from X to Y, or by finding an arc from X to Z, and then searching recursively for a path from Z to Y. Prolog executes the procedure by reasoning top-down (or backwards) and searching the space of possible paths depth-first, one branch at a time. If it tries the second clause, and finitely fails to find a path from Z to Y, it backtracks and tries to find an arc from X to another node, and then searches for a path from that other node to Y.\nHowever, in the logical reading of logic programs, clauses are understood declaratively as universally quantified conditionals. For example, the recursive clause of the path-finding procedure is understood as representing the knowledge that, for every X, Y and Z, if there is an arc from X to Z and a path from Z to Y then there is a path from X to Y. In symbolic form:\n```\n∀\n    X\n    ,\n    Y\n    ,\n    Z\n    (\n    a\n    r\n    c\n    (\n    X\n    ,\n    Z\n    )\n    ∧\n    p\n    a\n    t\n    h\n    (\n    Z\n    ,\n    Y\n    )\n    →\n    p\n    a\n    t\n    h\n    (\n    X\n    ,\n    Y\n    )\n    )\n    .\n  \n\n{\\displaystyle \\forall X,Y,Z(arc(X,Z)\\land path(Z,Y)\\rightarrow path(X,Y)).}\n```", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nIn the procedural interpretation of logic programs, clauses (or rules) of the form A :- B are treated as procedures, which reduce goals of the form A to subgoals of the form B.\nFor example, the Prolog clauses:\ndefine a  procedure, which can be used to search for a path from  X to  Y, either by finding a direct arc from X to Y, or by finding an arc from X to Z, and then searching recursively for a path from Z to Y. Prolog executes the procedure by reasoning top-down (or backwards) and searching the space of possible paths depth-first, one branch at a time. If it tries the second clause, and finitely fails to find a path from Z to Y, it backtracks and tries to find an arc from X to another node, and then searches for a path from that other node to Y.\nHowever, in the logical reading of logic programs, clauses are understood declaratively as universally quantified conditionals. For example, the recursive clause of the path-finding procedure is understood as representing the knowledge that, for every X, Y and Z, if there is an arc from X to Z and a path from Z to Y then there is a path from X to Y. In symbolic form:\n```\n∀\n    X\n    ,\n    Y\n    ,\n    Z\n    (\n    a\n    r\n    c\n    (\n    X\n    ,\n    Z\n    )\n    ∧\n    p\n    a\n    t\n    h\n    (\n    Z\n    ,\n    Y\n    )\n    →\n    p\n    a\n    t\n    h\n    (\n    X\n    ,\n    Y\n    )\n    )\n    .\n  \n\n{\\displaystyle \\forall X,Y,Z(arc(X,Z)\\land path(Z,Y)\\rightarrow path(X,Y)).}\n```", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nIn the procedural interpretation of logic programs, clauses (or rules) of the form A :- B are treated as procedures, which reduce goals of the form A to subgoals of the form B.\nFor example, the Prolog clauses:\ndefine a  procedure, which can be used to search for a path from  X to  Y, either by finding a direct arc from X to Y, or by finding an arc from X to Z, and then searching recursively for a path from Z to Y. Prolog executes the procedure by reasoning top-down (or backwards) and searching the space of possible paths depth-first, one branch at a time. If it tries the second clause, and finitely fails to find a path from Z to Y, it backtracks and tries to find an arc from X to another node, and then searches for a path from that other node to Y.\nHowever, in the logical reading of logic programs, clauses are understood declaratively as universally quantified conditionals. For example, the recursive clause of the path-finding procedure is understood as representing the knowledge that, for every X, Y and Z, if there is an arc from X to Z and a path from Z to Y then there is a path from X to Y. In symbolic form:\n```\n∀\n    X\n    ,\n    Y\n    ,\n    Z\n    (\n    a\n    r\n    c\n    (\n    X\n    ,\n    Z\n    )\n    ∧\n    p\n    a\n    t\n    h\n    (\n    Z\n    ,\n    Y\n    )\n    →\n    p\n    a\n    t\n    h\n    (\n    X\n    ,\n    Y\n    )\n    )\n    .\n  \n\n{\\displaystyle \\forall X,Y,Z(arc(X,Z)\\land path(Z,Y)\\rightarrow path(X,Y)).}\n```", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nIn the procedural interpretation of logic programs, clauses (or rules) of the form A :- B are treated as procedures, which reduce goals of the form A to subgoals of the form B.\nFor example, the Prolog clauses:\ndefine a  procedure, which can be used to search for a path from  X to  Y, either by finding a direct arc from X to Y, or by finding an arc from X to Z, and then searching recursively for a path from Z to Y. Prolog executes the procedure by reasoning top-down (or backwards) and searching the space of possible paths depth-first, one branch at a time. If it tries the second clause, and finitely fails to find a path from Z to Y, it backtracks and tries to find an arc from X to another node, and then searches for a path from that other node to Y.\nHowever, in the logical reading of logic programs, clauses are understood declaratively as universally quantified conditionals. For example, the recursive clause of the path-finding procedure is understood as representing the knowledge that, for every X, Y and Z, if there is an arc from X to Z and a path from Z to Y then there is a path from X to Y. In symbolic form:\n```\n∀\n    X\n    ,\n    Y\n    ,\n    Z\n    (\n    a\n    r\n    c\n    (\n    X\n    ,\n    Z\n    )\n    ∧\n    p\n    a\n    t\n    h\n    (\n    Z\n    ,\n    Y\n    )\n    →\n    p\n    a\n    t\n    h\n    (\n    X\n    ,\n    Y\n    )\n    )\n    .\n  \n\n{\\displaystyle \\forall X,Y,Z(arc(X,Z)\\land path(Z,Y)\\rightarrow path(X,Y)).}\n```", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nIn the procedural interpretation of logic programs, clauses (or rules) of the form A :- B are treated as procedures, which reduce goals of the form A to subgoals of the form B.\nFor example, the Prolog clauses:\ndefine a  procedure, which can be used to search for a path from  X to  Y, either by finding a direct arc from X to Y, or by finding an arc from X to Z, and then searching recursively for a path from Z to Y. Prolog executes the procedure by reasoning top-down (or backwards) and searching the space of possible paths depth-first, one branch at a time. If it tries the second clause, and finitely fails to find a path from Z to Y, it backtracks and tries to find an arc from X to another node, and then searches for a path from that other node to Y.\nHowever, in the logical reading of logic programs, clauses are understood declaratively as universally quantified conditionals. For example, the recursive clause of the path-finding procedure is understood as representing the knowledge that, for every X, Y and Z, if there is an arc from X to Z and a path from Z to Y then there is a path from X to Y. In symbolic form:\n```\n∀\n    X\n    ,\n    Y\n    ,\n    Z\n    (\n    a\n    r\n    c\n    (\n    X\n    ,\n    Z\n    )\n    ∧\n    p\n    a\n    t\n    h\n    (\n    Z\n    ,\n    Y\n    )\n    →\n    p\n    a\n    t\n    h\n    (\n    X\n    ,\n    Y\n    )\n    )\n    .\n  \n\n{\\displaystyle \\forall X,Y,Z(arc(X,Z)\\land path(Z,Y)\\rightarrow path(X,Y)).}\n```", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nThe logical reading frees the reader from needing to know how the clause is used to solve problems. The clause can be used top-down, as in Prolog, to reduce problems to subproblems. Or it can be used bottom-up (or forwards), as in Datalog, to derive conclusions from conditions. This separation of concerns is a form of abstraction, which separates declarative knowledge from problem solving methods (see Algorithm#Algorithm = Logic + Control).", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nThe logical reading frees the reader from needing to know how the clause is used to solve problems. The clause can be used top-down, as in Prolog, to reduce problems to subproblems. Or it can be used bottom-up (or forwards), as in Datalog, to derive conclusions from conditions. This separation of concerns is a form of abstraction, which separates declarative knowledge from problem solving methods (see Algorithm#Algorithm = Logic + Control).", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nThe logical reading frees the reader from needing to know how the clause is used to solve problems. The clause can be used top-down, as in Prolog, to reduce problems to subproblems. Or it can be used bottom-up (or forwards), as in Datalog, to derive conclusions from conditions. This separation of concerns is a form of abstraction, which separates declarative knowledge from problem solving methods (see Algorithm#Algorithm = Logic + Control).", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nThe logical reading frees the reader from needing to know how the clause is used to solve problems. The clause can be used top-down, as in Prolog, to reduce problems to subproblems. Or it can be used bottom-up (or forwards), as in Datalog, to derive conclusions from conditions. This separation of concerns is a form of abstraction, which separates declarative knowledge from problem solving methods (see Algorithm#Algorithm = Logic + Control).", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nRecursion in Logic Programming\nThe logical reading frees the reader from needing to know how the clause is used to solve problems. The clause can be used top-down, as in Prolog, to reduce problems to subproblems. Or it can be used bottom-up (or forwards), as in Datalog, to derive conclusions from conditions. This separation of concerns is a form of abstraction, which separates declarative knowledge from problem solving methods (see Algorithm#Algorithm = Logic + Control).", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nInfinite recursion\nA common mistake among programmers is not providing a way to exit a recursive function, often by omitting or incorrectly checking the base case, letting it run (at least theoretically) infinitely by endlessly calling itself recursively. This is called infinite recursion, and the program will never terminate. In practice, this typically exhausts the available stack space. In most programming environments, a program with infinite recursion will not really run forever. Eventually, something will break and the program will report an error.\nBelow is a Java code that would use infinite recursion:\nRunning this code will result in a stack overflow error.", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nInfinite recursion\nA common mistake among programmers is not providing a way to exit a recursive function, often by omitting or incorrectly checking the base case, letting it run (at least theoretically) infinitely by endlessly calling itself recursively. This is called infinite recursion, and the program will never terminate. In practice, this typically exhausts the available stack space. In most programming environments, a program with infinite recursion will not really run forever. Eventually, something will break and the program will report an error.\nBelow is a Java code that would use infinite recursion:\nRunning this code will result in a stack overflow error.", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nInfinite recursion\nA common mistake among programmers is not providing a way to exit a recursive function, often by omitting or incorrectly checking the base case, letting it run (at least theoretically) infinitely by endlessly calling itself recursively. This is called infinite recursion, and the program will never terminate. In practice, this typically exhausts the available stack space. In most programming environments, a program with infinite recursion will not really run forever. Eventually, something will break and the program will report an error.\nBelow is a Java code that would use infinite recursion:\nRunning this code will result in a stack overflow error.", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nInfinite recursion\nA common mistake among programmers is not providing a way to exit a recursive function, often by omitting or incorrectly checking the base case, letting it run (at least theoretically) infinitely by endlessly calling itself recursively. This is called infinite recursion, and the program will never terminate. In practice, this typically exhausts the available stack space. In most programming environments, a program with infinite recursion will not really run forever. Eventually, something will break and the program will report an error.\nBelow is a Java code that would use infinite recursion:\nRunning this code will result in a stack overflow error.", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nInfinite recursion\nA common mistake among programmers is not providing a way to exit a recursive function, often by omitting or incorrectly checking the base case, letting it run (at least theoretically) infinitely by endlessly calling itself recursively. This is called infinite recursion, and the program will never terminate. In practice, this typically exhausts the available stack space. In most programming environments, a program with infinite recursion will not really run forever. Eventually, something will break and the program will report an error.\nBelow is a Java code that would use infinite recursion:\nRunning this code will result in a stack overflow error.", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nSee also\nFunctional programming\nComputational problem\nHierarchical and recursive queries in SQL\nKleene–Rosser paradox\nOpen recursion\nRecursion (in general)\nSierpiński curve\nMcCarthy 91 function\nμ-recursive functions\nPrimitive recursive functions\nTak (function)\nLogic programming", "icl_document": "In computer science, recursion is a method of solving a computational problem where the solution\ndepends on solutions to smaller instances of the same problem. Recursion solves such recursive\nproblems by using functions that call themselves from within their own code. The approach can be\napplied to many types of problems, and recursion is one of the central ideas of computer science.\nThe power of recursion evidently lies in the possibility of defining an infinite set of objects\nby a finite statement. In the same manner, an infinite number of computations can be described by\na finite recursive program, even if this program contains no explicit repetitions\nMost computer programming languages support recursion by allowing a function to call itself from\nwithin its own code. Some functional programming languages (for instance, Clojure) do not define\nany looping constructs but rely solely on recursion to repeatedly call code. It is proved in\ncomputability theory that these recursive-only languages are Turing complete; this means that\nthey are as powerful (they can be used to solve the same problems) as imperative languages based\non control structures such as while and for.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is recursion in computer science?\n", "icl_response_1": "Recursion is a method where a function calls itself to solve a problem by breaking it into\nsmaller instances of the same problem.\n", "icl_query_2": "Why is recursion powerful?\n", "icl_response_2": "It allows defining infinite computations or objects with a finite statement, without explicit\nrepetitions.\n", "icl_query_3": "Do most programming languages support recursion?\n", "icl_response_3": "Yes, most allow functions to call themselves, and some rely solely on recursion instead of loops.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nSee also\nFunctional programming\nComputational problem\nHierarchical and recursive queries in SQL\nKleene–Rosser paradox\nOpen recursion\nRecursion (in general)\nSierpiński curve\nMcCarthy 91 function\nμ-recursive functions\nPrimitive recursive functions\nTak (function)\nLogic programming", "icl_document": "A recursive function definition has one or more base cases, meaning input(s) for which the\nfunction produces a result trivially (without recurring), and one or more recursive cases, meaning\ninput(s) for which the program recurs (calls itself). For example, the factorial function can be\ndefined recursively by the equations 0! = 1 and, for all n > 0, n! = n(n - 1)!. Neither equation by\nitself constitutes a complete definition; the first is the base case, and the second is the\nrecursive case. Because the base case breaks the chain of recursion, it is sometimes also called\nthe \"terminating case\".\nThe job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a\nproperly designed recursive function, with each recursive call, the input problem must be simplified\nin such a way that eventually the base case must be reached. Neglecting to write a base case, or\ntesting for it incorrectly, can cause an infinite loop.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is a base case in a recursive function?\n", "icl_response_1": "It's the input where the function returns a result without calling itself, like 0! = 1 in factorial.\n", "icl_query_2": "What happens in the recursive case?\n", "icl_response_2": "The function calls itself with a simpler input, breaking down the problem until the base case is\nreached.\n", "icl_query_3": "Why is the base case important?\n", "icl_response_3": "It stops the recursion; without it, the function might cause an infinite loop.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nSee also\nFunctional programming\nComputational problem\nHierarchical and recursive queries in SQL\nKleene–Rosser paradox\nOpen recursion\nRecursion (in general)\nSierpiński curve\nMcCarthy 91 function\nμ-recursive functions\nPrimitive recursive functions\nTak (function)\nLogic programming", "icl_document": "Recursion that contains only a single self-reference is known as single recursion, while recursion\nthat contains multiple self-references is known as multiple recursion. Standard examples of single\nrecursion include list traversal, such as in a linear search, or computing the factorial function,\nwhile standard examples of multiple recursion include tree traversal, such as in a depth-first\nsearch.\nSingle recursion is often much more efficient than multiple recursion, and can generally be replaced\nby an iterative computation, running in linear time and requiring constant space. Multiple recursion,\nby contrast, may require exponential time and space, and is more fundamentally recursive, not being\nable to be replaced by iteration without an explicit stack.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is single recursion?\n", "icl_response_1": "It's recursion with only one self-reference, like in factorial or linear search.\n", "icl_query_2": "What is multiple recursion?\n", "icl_response_2": "It's recursion with multiple self-references, like in tree traversal or depth-first search.\n", "icl_query_3": "How do single and multiple recursion differ in efficiency?\n", "icl_response_3": "Single is often more efficient and can be iterative; multiple may need more time and space.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nSee also\nFunctional programming\nComputational problem\nHierarchical and recursive queries in SQL\nKleene–Rosser paradox\nOpen recursion\nRecursion (in general)\nSierpiński curve\nMcCarthy 91 function\nμ-recursive functions\nPrimitive recursive functions\nTak (function)\nLogic programming", "icl_document": "Recursion and iteration are equally expressive: recursion can be replaced by iteration with an\nexplicit call stack, while iteration can be replaced with tail recursion. Which approach is\npreferable depends on the problem under consideration and the language used. In imperative\nprogramming, iteration is preferred, particularly for simple recursion, as it avoids the overhead\nof function calls and call stack management, but recursion is generally used for multiple recursion.\nBy contrast, in functional languages recursion is preferred, with tail recursion optimization leading\nto little overhead. Implementing an algorithm using iteration may not be easily achievable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "Are recursion and iteration equally powerful?\n", "icl_response_1": "Yes, recursion can be turned into iteration with a stack, and iteration into recursion.\n", "icl_query_2": "When is iteration preferred over recursion?\n", "icl_response_2": "In imperative languages for simple cases, to avoid function call overhead.\n", "icl_query_3": "When is recursion preferred?\n", "icl_response_3": "In functional languages or for complex problems like multiple recursion.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
{"document": "Recursion_(computer_science)\nSee also\nFunctional programming\nComputational problem\nHierarchical and recursive queries in SQL\nKleene–Rosser paradox\nOpen recursion\nRecursion (in general)\nSierpiński curve\nMcCarthy 91 function\nμ-recursive functions\nPrimitive recursive functions\nTak (function)\nLogic programming", "icl_document": "A classic example of a recursive procedure is the function used to calculate the factorial of a\nnatural number:\nfact(n) = { 1 if n=0; n · fact(n-1) if n>0 }\nThe function can also be written as a recurrence relation:\nb_n = n b_{n-1}\nb_0 = 1\nThis factorial function can also be described without using recursion by making use of the typical\nlooping constructs found in imperative programming languages.\nThe imperative code is equivalent to a mathematical definition using an accumulator variable.\n", "document_outline": "Recursion in computer science, covering its definition, characteristics, types, and practical examples\nlike factorial and binary search.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How is factorial defined recursively?\n", "icl_response_1": "fact(n) = 1 if n=0, else n * fact(n-1).\n", "icl_query_2": "What is the base case in factorial?\n", "icl_response_2": "When n=0, fact(0)=1.\n", "icl_query_3": "Can factorial be done without recursion?\n", "icl_response_3": "Yes, using loops in imperative languages.\n", "leaf_node_path": "knowledge_technology_computer_science_programming_paradigms_functional_recursion"}
