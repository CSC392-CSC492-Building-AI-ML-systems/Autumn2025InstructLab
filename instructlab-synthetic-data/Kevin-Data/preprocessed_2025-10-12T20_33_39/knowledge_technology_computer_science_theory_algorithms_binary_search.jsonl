{"document": "Binary_search\nIn computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\nBinary search runs in logarithmic time in the worst case, making\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\ncomparisons, where\n```\nn\n  \n\n{\\displaystyle n}\n```\nis the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array.\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nIn computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\nBinary search runs in logarithmic time in the worst case, making\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\ncomparisons, where\n```\nn\n  \n\n{\\displaystyle n}\n```\nis the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array.\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nIn computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\nBinary search runs in logarithmic time in the worst case, making\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\ncomparisons, where\n```\nn\n  \n\n{\\displaystyle n}\n```\nis the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array.\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nIn computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\nBinary search runs in logarithmic time in the worst case, making\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\ncomparisons, where\n```\nn\n  \n\n{\\displaystyle n}\n```\nis the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array.\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nIn computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\nBinary search runs in logarithmic time in the worst case, making\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\ncomparisons, where\n```\nn\n  \n\n{\\displaystyle n}\n```\nis the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array.\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nBinary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nBinary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nBinary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nBinary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nBinary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nGiven an array\n```\nA\n  \n\n{\\displaystyle A}\n```\nof\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements with values or records\n```\nA\n      \n        0\n      \n    \n    ,\n    \n      A\n      \n        1\n      \n    \n    ,\n    \n      A\n      \n        2\n      \n    \n    ,\n    …\n    ,\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0},A_{1},A_{2},\\ldots ,A_{n-1}}\n```\nsorted such that\n```\nA\n      \n        0\n      \n    \n    ≤\n    \n      A\n      \n        1\n      \n    \n    ≤\n    \n      A\n      \n        2\n      \n    \n    ≤\n    ⋯\n    ≤\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}}\n```\n, and target value\n```\nT\n  \n\n{\\displaystyle T}\n```\n, the following subroutine uses binary search to find the index of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin\n```\nA\n  \n\n{\\displaystyle A}\n```\n.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nIf\n```\nL\n    >\n    R\n  \n\n{\\displaystyle L>R}\n```\n, the search terminates as unsuccessful.\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nGiven an array\n```\nA\n  \n\n{\\displaystyle A}\n```\nof\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements with values or records\n```\nA\n      \n        0\n      \n    \n    ,\n    \n      A\n      \n        1\n      \n    \n    ,\n    \n      A\n      \n        2\n      \n    \n    ,\n    …\n    ,\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0},A_{1},A_{2},\\ldots ,A_{n-1}}\n```\nsorted such that\n```\nA\n      \n        0\n      \n    \n    ≤\n    \n      A\n      \n        1\n      \n    \n    ≤\n    \n      A\n      \n        2\n      \n    \n    ≤\n    ⋯\n    ≤\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}}\n```\n, and target value\n```\nT\n  \n\n{\\displaystyle T}\n```\n, the following subroutine uses binary search to find the index of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin\n```\nA\n  \n\n{\\displaystyle A}\n```\n.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nIf\n```\nL\n    >\n    R\n  \n\n{\\displaystyle L>R}\n```\n, the search terminates as unsuccessful.\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nGiven an array\n```\nA\n  \n\n{\\displaystyle A}\n```\nof\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements with values or records\n```\nA\n      \n        0\n      \n    \n    ,\n    \n      A\n      \n        1\n      \n    \n    ,\n    \n      A\n      \n        2\n      \n    \n    ,\n    …\n    ,\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0},A_{1},A_{2},\\ldots ,A_{n-1}}\n```\nsorted such that\n```\nA\n      \n        0\n      \n    \n    ≤\n    \n      A\n      \n        1\n      \n    \n    ≤\n    \n      A\n      \n        2\n      \n    \n    ≤\n    ⋯\n    ≤\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}}\n```\n, and target value\n```\nT\n  \n\n{\\displaystyle T}\n```\n, the following subroutine uses binary search to find the index of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin\n```\nA\n  \n\n{\\displaystyle A}\n```\n.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nIf\n```\nL\n    >\n    R\n  \n\n{\\displaystyle L>R}\n```\n, the search terminates as unsuccessful.\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nGiven an array\n```\nA\n  \n\n{\\displaystyle A}\n```\nof\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements with values or records\n```\nA\n      \n        0\n      \n    \n    ,\n    \n      A\n      \n        1\n      \n    \n    ,\n    \n      A\n      \n        2\n      \n    \n    ,\n    …\n    ,\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0},A_{1},A_{2},\\ldots ,A_{n-1}}\n```\nsorted such that\n```\nA\n      \n        0\n      \n    \n    ≤\n    \n      A\n      \n        1\n      \n    \n    ≤\n    \n      A\n      \n        2\n      \n    \n    ≤\n    ⋯\n    ≤\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}}\n```\n, and target value\n```\nT\n  \n\n{\\displaystyle T}\n```\n, the following subroutine uses binary search to find the index of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin\n```\nA\n  \n\n{\\displaystyle A}\n```\n.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nIf\n```\nL\n    >\n    R\n  \n\n{\\displaystyle L>R}\n```\n, the search terminates as unsuccessful.\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nGiven an array\n```\nA\n  \n\n{\\displaystyle A}\n```\nof\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements with values or records\n```\nA\n      \n        0\n      \n    \n    ,\n    \n      A\n      \n        1\n      \n    \n    ,\n    \n      A\n      \n        2\n      \n    \n    ,\n    …\n    ,\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0},A_{1},A_{2},\\ldots ,A_{n-1}}\n```\nsorted such that\n```\nA\n      \n        0\n      \n    \n    ≤\n    \n      A\n      \n        1\n      \n    \n    ≤\n    \n      A\n      \n        2\n      \n    \n    ≤\n    ⋯\n    ≤\n    \n      A\n      \n        n\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}}\n```\n, and target value\n```\nT\n  \n\n{\\displaystyle T}\n```\n, the following subroutine uses binary search to find the index of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin\n```\nA\n  \n\n{\\displaystyle A}\n```\n.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nIf\n```\nL\n    >\n    R\n  \n\n{\\displaystyle L>R}\n```\n, the search terminates as unsuccessful.\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\nand go to step 2.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\nand go to step 2.\nNow\n```\nA\n      \n        m\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{m}=T}\n```\n, the search is done; return\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nThis iterative procedure keeps track of the search boundaries with the two variables\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function, and unsuccessful refers to a specific value that conveys the failure of the search.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\nand go to step 2.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\nand go to step 2.\nNow\n```\nA\n      \n        m\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{m}=T}\n```\n, the search is done; return\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nThis iterative procedure keeps track of the search boundaries with the two variables\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function, and unsuccessful refers to a specific value that conveys the failure of the search.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\nand go to step 2.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\nand go to step 2.\nNow\n```\nA\n      \n        m\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{m}=T}\n```\n, the search is done; return\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nThis iterative procedure keeps track of the search boundaries with the two variables\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function, and unsuccessful refers to a specific value that conveys the failure of the search.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\nand go to step 2.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\nand go to step 2.\nNow\n```\nA\n      \n        m\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{m}=T}\n```\n, the search is done; return\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nThis iterative procedure keeps track of the search boundaries with the two variables\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function, and unsuccessful refers to a specific value that conveys the failure of the search.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\nand go to step 2.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\nand go to step 2.\nNow\n```\nA\n      \n        m\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{m}=T}\n```\n, the search is done; return\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nThis iterative procedure keeps track of the search boundaries with the two variables\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function, and unsuccessful refers to a specific value that conveys the failure of the search.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nfunction binary_search(A, n, T) is\nL := 0\nR := n − 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m − 1\nelse:\nreturn m\nreturn unsuccessful\nAlternatively, the algorithm may take the ceiling of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n. This may change the result if the target value appears more than once in the array.\n=### Alternative procedure=\nIn the above procedure, the algorithm checks whether the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) is equal to the target (\n```\nT\n  \n\n{\\displaystyle T}\n```\n) in every iteration. Some implementations leave out this check during each iteration. The algorithm would perform this check only when one element is left (when\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n). This results in a faster comparison loop, as one comparison is eliminated per iteration, while it requires only one more iteration on average.\nHermann Bottenbruch published the first implementation to leave out this check in 1962.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nWhile\n```\nL\n    ≠\n    R\n  \n\n{\\displaystyle L\\neq R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the ceiling of", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nfunction binary_search(A, n, T) is\nL := 0\nR := n − 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m − 1\nelse:\nreturn m\nreturn unsuccessful\nAlternatively, the algorithm may take the ceiling of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n. This may change the result if the target value appears more than once in the array.\n=### Alternative procedure=\nIn the above procedure, the algorithm checks whether the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) is equal to the target (\n```\nT\n  \n\n{\\displaystyle T}\n```\n) in every iteration. Some implementations leave out this check during each iteration. The algorithm would perform this check only when one element is left (when\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n). This results in a faster comparison loop, as one comparison is eliminated per iteration, while it requires only one more iteration on average.\nHermann Bottenbruch published the first implementation to leave out this check in 1962.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nWhile\n```\nL\n    ≠\n    R\n  \n\n{\\displaystyle L\\neq R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the ceiling of", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nfunction binary_search(A, n, T) is\nL := 0\nR := n − 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m − 1\nelse:\nreturn m\nreturn unsuccessful\nAlternatively, the algorithm may take the ceiling of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n. This may change the result if the target value appears more than once in the array.\n=### Alternative procedure=\nIn the above procedure, the algorithm checks whether the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) is equal to the target (\n```\nT\n  \n\n{\\displaystyle T}\n```\n) in every iteration. Some implementations leave out this check during each iteration. The algorithm would perform this check only when one element is left (when\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n). This results in a faster comparison loop, as one comparison is eliminated per iteration, while it requires only one more iteration on average.\nHermann Bottenbruch published the first implementation to leave out this check in 1962.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nWhile\n```\nL\n    ≠\n    R\n  \n\n{\\displaystyle L\\neq R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the ceiling of", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nfunction binary_search(A, n, T) is\nL := 0\nR := n − 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m − 1\nelse:\nreturn m\nreturn unsuccessful\nAlternatively, the algorithm may take the ceiling of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n. This may change the result if the target value appears more than once in the array.\n=### Alternative procedure=\nIn the above procedure, the algorithm checks whether the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) is equal to the target (\n```\nT\n  \n\n{\\displaystyle T}\n```\n) in every iteration. Some implementations leave out this check during each iteration. The algorithm would perform this check only when one element is left (when\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n). This results in a faster comparison loop, as one comparison is eliminated per iteration, while it requires only one more iteration on average.\nHermann Bottenbruch published the first implementation to leave out this check in 1962.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nWhile\n```\nL\n    ≠\n    R\n  \n\n{\\displaystyle L\\neq R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the ceiling of", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\nfunction binary_search(A, n, T) is\nL := 0\nR := n − 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m − 1\nelse:\nreturn m\nreturn unsuccessful\nAlternatively, the algorithm may take the ceiling of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n. This may change the result if the target value appears more than once in the array.\n=### Alternative procedure=\nIn the above procedure, the algorithm checks whether the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) is equal to the target (\n```\nT\n  \n\n{\\displaystyle T}\n```\n) in every iteration. Some implementations leave out this check during each iteration. The algorithm would perform this check only when one element is left (when\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n). This results in a faster comparison loop, as one comparison is eliminated per iteration, while it requires only one more iteration on average.\nHermann Bottenbruch published the first implementation to leave out this check in 1962.\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n    −\n    1\n  \n\n{\\displaystyle n-1}\n```\n.\nWhile\n```\nL\n    ≠\n    R\n  \n\n{\\displaystyle L\\neq R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the ceiling of", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the least integer greater than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nNow\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n, the search is done. If\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, return\n```\nL\n  \n\n{\\displaystyle L}\n```\n. Otherwise, the search terminates as unsuccessful.\nWhere ceil is the ceiling function, the pseudocode for this version is:\nfunction binary_search_alternative(A, n, T) is\nL := 0\nR := n − 1\nwhile L != R do\nm := L + ceil((R - L) / 2)\nif A[m] > T then\nR := m − 1\nelse:\nL := m\nif A[L] = T then\nreturn L\nreturn unsuccessful", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the least integer greater than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nNow\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n, the search is done. If\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, return\n```\nL\n  \n\n{\\displaystyle L}\n```\n. Otherwise, the search terminates as unsuccessful.\nWhere ceil is the ceiling function, the pseudocode for this version is:\nfunction binary_search_alternative(A, n, T) is\nL := 0\nR := n − 1\nwhile L != R do\nm := L + ceil((R - L) / 2)\nif A[m] > T then\nR := m − 1\nelse:\nL := m\nif A[L] = T then\nreturn L\nreturn unsuccessful", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the least integer greater than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nNow\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n, the search is done. If\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, return\n```\nL\n  \n\n{\\displaystyle L}\n```\n. Otherwise, the search terminates as unsuccessful.\nWhere ceil is the ceiling function, the pseudocode for this version is:\nfunction binary_search_alternative(A, n, T) is\nL := 0\nR := n − 1\nwhile L != R do\nm := L + ceil((R - L) / 2)\nif A[m] > T then\nR := m − 1\nelse:\nL := m\nif A[L] = T then\nreturn L\nreturn unsuccessful", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the least integer greater than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nNow\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n, the search is done. If\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, return\n```\nL\n  \n\n{\\displaystyle L}\n```\n. Otherwise, the search terminates as unsuccessful.\nWhere ceil is the ceiling function, the pseudocode for this version is:\nfunction binary_search_alternative(A, n, T) is\nL := 0\nR := n − 1\nwhile L != R do\nm := L + ceil((R - L) / 2)\nif A[m] > T then\nR := m − 1\nelse:\nL := m\nif A[L] = T then\nreturn L\nreturn unsuccessful", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nProcedure\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the least integer greater than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n    −\n    1\n  \n\n{\\displaystyle m-1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nNow\n```\nL\n    =\n    R\n  \n\n{\\displaystyle L=R}\n```\n, the search is done. If\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, return\n```\nL\n  \n\n{\\displaystyle L}\n```\n. Otherwise, the search terminates as unsuccessful.\nWhere ceil is the ceiling function, the pseudocode for this version is:\nfunction binary_search_alternative(A, n, T) is\nL := 0\nR := n − 1\nwhile L != R do\nm := L + ceil((R - L) / 2)\nif A[m] > T then\nR := m − 1\nelse:\nL := m\nif A[L] = T then\nreturn L\nreturn unsuccessful", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nThe procedure may return any index whose element is equal to the target value, even if there are duplicate elements in the array. For example, if the array to be searched was\n```\n[\n    1\n    ,\n    2\n    ,\n    3\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,3,4,4,5,6,7]}\n```\nand the target was\n```\n4\n  \n\n{\\displaystyle 4}\n```\n, then it would be correct for the algorithm to either return the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element (index 3) in this case. It does not always return the first duplicate (consider\n```\n[\n    1\n    ,\n    2\n    ,\n    4\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,4,4,4,5,6,7]}\n```\nwhich still returns the 4th element). However, it is sometimes necessary to find the leftmost element or the rightmost element for a target value that is duplicated in the array. In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists.\n=### Procedure for finding the leftmost element=\nTo find the leftmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nThe procedure may return any index whose element is equal to the target value, even if there are duplicate elements in the array. For example, if the array to be searched was\n```\n[\n    1\n    ,\n    2\n    ,\n    3\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,3,4,4,5,6,7]}\n```\nand the target was\n```\n4\n  \n\n{\\displaystyle 4}\n```\n, then it would be correct for the algorithm to either return the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element (index 3) in this case. It does not always return the first duplicate (consider\n```\n[\n    1\n    ,\n    2\n    ,\n    4\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,4,4,4,5,6,7]}\n```\nwhich still returns the 4th element). However, it is sometimes necessary to find the leftmost element or the rightmost element for a target value that is duplicated in the array. In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists.\n=### Procedure for finding the leftmost element=\nTo find the leftmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nThe procedure may return any index whose element is equal to the target value, even if there are duplicate elements in the array. For example, if the array to be searched was\n```\n[\n    1\n    ,\n    2\n    ,\n    3\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,3,4,4,5,6,7]}\n```\nand the target was\n```\n4\n  \n\n{\\displaystyle 4}\n```\n, then it would be correct for the algorithm to either return the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element (index 3) in this case. It does not always return the first duplicate (consider\n```\n[\n    1\n    ,\n    2\n    ,\n    4\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,4,4,4,5,6,7]}\n```\nwhich still returns the 4th element). However, it is sometimes necessary to find the leftmost element or the rightmost element for a target value that is duplicated in the array. In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists.\n=### Procedure for finding the leftmost element=\nTo find the leftmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nThe procedure may return any index whose element is equal to the target value, even if there are duplicate elements in the array. For example, if the array to be searched was\n```\n[\n    1\n    ,\n    2\n    ,\n    3\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,3,4,4,5,6,7]}\n```\nand the target was\n```\n4\n  \n\n{\\displaystyle 4}\n```\n, then it would be correct for the algorithm to either return the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element (index 3) in this case. It does not always return the first duplicate (consider\n```\n[\n    1\n    ,\n    2\n    ,\n    4\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,4,4,4,5,6,7]}\n```\nwhich still returns the 4th element). However, it is sometimes necessary to find the leftmost element or the rightmost element for a target value that is duplicated in the array. In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists.\n=### Procedure for finding the leftmost element=\nTo find the leftmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nThe procedure may return any index whose element is equal to the target value, even if there are duplicate elements in the array. For example, if the array to be searched was\n```\n[\n    1\n    ,\n    2\n    ,\n    3\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,3,4,4,5,6,7]}\n```\nand the target was\n```\n4\n  \n\n{\\displaystyle 4}\n```\n, then it would be correct for the algorithm to either return the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element (index 3) in this case. It does not always return the first duplicate (consider\n```\n[\n    1\n    ,\n    2\n    ,\n    4\n    ,\n    4\n    ,\n    4\n    ,\n    5\n    ,\n    6\n    ,\n    7\n    ]\n  \n\n{\\displaystyle [1,2,4,4,4,5,6,7]}\n```\nwhich still returns the 4th element). However, it is sometimes necessary to find the leftmost element or the rightmost element for a target value that is duplicated in the array. In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists.\n=### Procedure for finding the leftmost element=\nTo find the leftmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≥\n    T\n  \n\n{\\displaystyle A_{m}\\geq T}\n```\n; set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nReturn\n```\nL\n  \n\n{\\displaystyle L}\n```\n.\nIf\n```\nL\n    <\n    n\n  \n\n{\\displaystyle L<n}\n```\nand\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, then\n```\nA\n      \n        L\n      \n    \n  \n\n{\\displaystyle A_{L}}\n```\nis the leftmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≥\n    T\n  \n\n{\\displaystyle A_{m}\\geq T}\n```\n; set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nReturn\n```\nL\n  \n\n{\\displaystyle L}\n```\n.\nIf\n```\nL\n    <\n    n\n  \n\n{\\displaystyle L<n}\n```\nand\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, then\n```\nA\n      \n        L\n      \n    \n  \n\n{\\displaystyle A_{L}}\n```\nis the leftmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≥\n    T\n  \n\n{\\displaystyle A_{m}\\geq T}\n```\n; set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nReturn\n```\nL\n  \n\n{\\displaystyle L}\n```\n.\nIf\n```\nL\n    <\n    n\n  \n\n{\\displaystyle L<n}\n```\nand\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, then\n```\nA\n      \n        L\n      \n    \n  \n\n{\\displaystyle A_{L}}\n```\nis the leftmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≥\n    T\n  \n\n{\\displaystyle A_{m}\\geq T}\n```\n; set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nReturn\n```\nL\n  \n\n{\\displaystyle L}\n```\n.\nIf\n```\nL\n    <\n    n\n  \n\n{\\displaystyle L<n}\n```\nand\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, then\n```\nA\n      \n        L\n      \n    \n  \n\n{\\displaystyle A_{L}}\n```\nis the leftmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    <\n    T\n  \n\n{\\displaystyle A_{m}<T}\n```\n, set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≥\n    T\n  \n\n{\\displaystyle A_{m}\\geq T}\n```\n; set\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nReturn\n```\nL\n  \n\n{\\displaystyle L}\n```\n.\nIf\n```\nL\n    <\n    n\n  \n\n{\\displaystyle L<n}\n```\nand\n```\nA\n      \n        L\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{L}=T}\n```\n, then\n```\nA\n      \n        L\n      \n    \n  \n\n{\\displaystyle A_{L}}\n```\nis the leftmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nis not in the array,\n```\nL\n  \n\n{\\displaystyle L}\n```\nis the rank of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin the array, or the number of elements in the array that are less than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_leftmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] < T:\nL := m + 1\nelse:\nR := m\nreturn L\n=### Procedure for finding the rightmost element=\nTo find the rightmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nis not in the array,\n```\nL\n  \n\n{\\displaystyle L}\n```\nis the rank of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin the array, or the number of elements in the array that are less than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_leftmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] < T:\nL := m + 1\nelse:\nR := m\nreturn L\n=### Procedure for finding the rightmost element=\nTo find the rightmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nis not in the array,\n```\nL\n  \n\n{\\displaystyle L}\n```\nis the rank of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin the array, or the number of elements in the array that are less than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_leftmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] < T:\nL := m + 1\nelse:\nR := m\nreturn L\n=### Procedure for finding the rightmost element=\nTo find the rightmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nis not in the array,\n```\nL\n  \n\n{\\displaystyle L}\n```\nis the rank of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin the array, or the number of elements in the array that are less than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_leftmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] < T:\nL := m + 1\nelse:\nR := m\nreturn L\n=### Procedure for finding the rightmost element=\nTo find the rightmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\nis not in the array,\n```\nL\n  \n\n{\\displaystyle L}\n```\nis the rank of\n```\nT\n  \n\n{\\displaystyle T}\n```\nin the array, or the number of elements in the array that are less than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_leftmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] < T:\nL := m + 1\nelse:\nR := m\nreturn L\n=### Procedure for finding the rightmost element=\nTo find the rightmost element, the following procedure can be used:\nSet\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\n0\n  \n\n{\\displaystyle 0}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nn\n  \n\n{\\displaystyle n}\n```\n.\nWhile\n```\nL\n    <\n    R\n  \n\n{\\displaystyle L<R}\n```\n,\nSet\n```\nm\n  \n\n{\\displaystyle m}\n```\n(the position of the middle element) to\n```\nL\n  \n\n{\\displaystyle L}\n```\nplus the floor of\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n, which is the greatest integer less than or equal to\n```\nR\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {R-L}{2}}}\n```\n.\nIf\n```\nA\n      \n        m\n      \n    \n    >\n    T\n  \n\n{\\displaystyle A_{m}>T}\n```\n, set", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nReturn\n```\nR\n    −\n    1\n  \n\n{\\displaystyle R-1}\n```\n.\nIf\n```\nR\n    >\n    0\n  \n\n{\\displaystyle R>0}\n```\nand\n```\nA\n      \n        R\n        −\n        1\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{R-1}=T}\n```\n, then\n```\nA\n      \n        R\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{R-1}}\n```\nis the rightmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```\nis not in the array,\n```\nn\n    −\n    R\n  \n\n{\\displaystyle n-R}\n```\nis the number of elements in the array that are greater than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_rightmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] > T:\nR := m\nelse:\nL := m + 1\nreturn R - 1", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nReturn\n```\nR\n    −\n    1\n  \n\n{\\displaystyle R-1}\n```\n.\nIf\n```\nR\n    >\n    0\n  \n\n{\\displaystyle R>0}\n```\nand\n```\nA\n      \n        R\n        −\n        1\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{R-1}=T}\n```\n, then\n```\nA\n      \n        R\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{R-1}}\n```\nis the rightmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```\nis not in the array,\n```\nn\n    −\n    R\n  \n\n{\\displaystyle n-R}\n```\nis the number of elements in the array that are greater than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_rightmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] > T:\nR := m\nelse:\nL := m + 1\nreturn R - 1", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nReturn\n```\nR\n    −\n    1\n  \n\n{\\displaystyle R-1}\n```\n.\nIf\n```\nR\n    >\n    0\n  \n\n{\\displaystyle R>0}\n```\nand\n```\nA\n      \n        R\n        −\n        1\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{R-1}=T}\n```\n, then\n```\nA\n      \n        R\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{R-1}}\n```\nis the rightmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```\nis not in the array,\n```\nn\n    −\n    R\n  \n\n{\\displaystyle n-R}\n```\nis the number of elements in the array that are greater than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_rightmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] > T:\nR := m\nelse:\nL := m + 1\nreturn R - 1", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nReturn\n```\nR\n    −\n    1\n  \n\n{\\displaystyle R-1}\n```\n.\nIf\n```\nR\n    >\n    0\n  \n\n{\\displaystyle R>0}\n```\nand\n```\nA\n      \n        R\n        −\n        1\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{R-1}=T}\n```\n, then\n```\nA\n      \n        R\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{R-1}}\n```\nis the rightmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```\nis not in the array,\n```\nn\n    −\n    R\n  \n\n{\\displaystyle n-R}\n```\nis the number of elements in the array that are greater than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_rightmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] > T:\nR := m\nelse:\nL := m + 1\nreturn R - 1", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nDuplicate elements\n```\nR\n  \n\n{\\displaystyle R}\n```\nto\n```\nm\n  \n\n{\\displaystyle m}\n```\n.\nElse,\n```\nA\n      \n        m\n      \n    \n    ≤\n    T\n  \n\n{\\displaystyle A_{m}\\leq T}\n```\n; set\n```\nL\n  \n\n{\\displaystyle L}\n```\nto\n```\nm\n    +\n    1\n  \n\n{\\displaystyle m+1}\n```\n.\nReturn\n```\nR\n    −\n    1\n  \n\n{\\displaystyle R-1}\n```\n.\nIf\n```\nR\n    >\n    0\n  \n\n{\\displaystyle R>0}\n```\nand\n```\nA\n      \n        R\n        −\n        1\n      \n    \n    =\n    T\n  \n\n{\\displaystyle A_{R-1}=T}\n```\n, then\n```\nA\n      \n        R\n        −\n        1\n      \n    \n  \n\n{\\displaystyle A_{R-1}}\n```\nis the rightmost element that equals\n```\nT\n  \n\n{\\displaystyle T}\n```\n. Even if\n```\nT\n  \n\n{\\displaystyle T}\n```\nis not in the array,\n```\nn\n    −\n    R\n  \n\n{\\displaystyle n-R}\n```\nis the number of elements in the array that are greater than\n```\nT\n  \n\n{\\displaystyle T}\n```\n.\nWhere floor is the floor function, the pseudocode for this version is:\nfunction binary_search_rightmost(A, n, T):\nL := 0\nR := n\nwhile L < R:\nm := L + floor((R - L) / 2)\nif A[m] > T:\nR := m\nelse:\nL := m + 1\nreturn R - 1", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nApproximate matches\nThe above procedure only performs exact matches, finding the position of a target value. However, it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\nRank queries can be performed with the procedure for finding the leftmost element. The number of elements less than the target value is returned by the procedure.\nPredecessor queries can be performed with rank queries. If the rank of the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, its predecessor is\n```\nr\n    −\n    1\n  \n\n{\\displaystyle r-1}\n```\n.\nFor successor queries, the procedure for finding the rightmost element can be used. If the result of running the procedure for the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, then the successor of the target value is\n```\nr\n    +\n    1\n  \n\n{\\displaystyle r+1}\n```\n.\nThe nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\nRange queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains entries matching those endpoints.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nApproximate matches\nThe above procedure only performs exact matches, finding the position of a target value. However, it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\nRank queries can be performed with the procedure for finding the leftmost element. The number of elements less than the target value is returned by the procedure.\nPredecessor queries can be performed with rank queries. If the rank of the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, its predecessor is\n```\nr\n    −\n    1\n  \n\n{\\displaystyle r-1}\n```\n.\nFor successor queries, the procedure for finding the rightmost element can be used. If the result of running the procedure for the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, then the successor of the target value is\n```\nr\n    +\n    1\n  \n\n{\\displaystyle r+1}\n```\n.\nThe nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\nRange queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains entries matching those endpoints.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nApproximate matches\nThe above procedure only performs exact matches, finding the position of a target value. However, it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\nRank queries can be performed with the procedure for finding the leftmost element. The number of elements less than the target value is returned by the procedure.\nPredecessor queries can be performed with rank queries. If the rank of the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, its predecessor is\n```\nr\n    −\n    1\n  \n\n{\\displaystyle r-1}\n```\n.\nFor successor queries, the procedure for finding the rightmost element can be used. If the result of running the procedure for the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, then the successor of the target value is\n```\nr\n    +\n    1\n  \n\n{\\displaystyle r+1}\n```\n.\nThe nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\nRange queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains entries matching those endpoints.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nApproximate matches\nThe above procedure only performs exact matches, finding the position of a target value. However, it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\nRank queries can be performed with the procedure for finding the leftmost element. The number of elements less than the target value is returned by the procedure.\nPredecessor queries can be performed with rank queries. If the rank of the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, its predecessor is\n```\nr\n    −\n    1\n  \n\n{\\displaystyle r-1}\n```\n.\nFor successor queries, the procedure for finding the rightmost element can be used. If the result of running the procedure for the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, then the successor of the target value is\n```\nr\n    +\n    1\n  \n\n{\\displaystyle r+1}\n```\n.\nThe nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\nRange queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains entries matching those endpoints.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nAlgorithm\nApproximate matches\nThe above procedure only performs exact matches, finding the position of a target value. However, it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\nRank queries can be performed with the procedure for finding the leftmost element. The number of elements less than the target value is returned by the procedure.\nPredecessor queries can be performed with rank queries. If the rank of the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, its predecessor is\n```\nr\n    −\n    1\n  \n\n{\\displaystyle r-1}\n```\n.\nFor successor queries, the procedure for finding the rightmost element can be used. If the result of running the procedure for the target value is\n```\nr\n  \n\n{\\displaystyle r}\n```\n, then the successor of the target value is\n```\nr\n    +\n    1\n  \n\n{\\displaystyle r+1}\n```\n.\nThe nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\nRange queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains entries matching those endpoints.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nIn terms of the number of comparisons, the performance of binary search can be analyzed by viewing the run of the procedure on a binary tree. The root node of the tree is the middle element of the array. The middle element of the lower half is the left child node of the root, and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. Starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration.\nIn the worst case, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations of the comparison loop, where the\n```\n⌊\n    ⋅\n    ⌋\n  \n\n{\\textstyle \\lfloor \\cdot \\rfloor }\n```\nnotation denotes the floor function that yields the greatest integer less than or equal to the argument, and\n```\nlog\n      \n        2\n      \n    \n  \n\n{\\textstyle \\log _{2}}\n```\nis the binary logarithm. This is because the worst case is reached when the search reaches the deepest level of the tree, and there are always\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\nlevels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. If\n```\nn\n  \n\n{\\textstyle n}\n```\nis one less than a power of two, then this is always the case. Otherwise, the search may perform", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nIn terms of the number of comparisons, the performance of binary search can be analyzed by viewing the run of the procedure on a binary tree. The root node of the tree is the middle element of the array. The middle element of the lower half is the left child node of the root, and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. Starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration.\nIn the worst case, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations of the comparison loop, where the\n```\n⌊\n    ⋅\n    ⌋\n  \n\n{\\textstyle \\lfloor \\cdot \\rfloor }\n```\nnotation denotes the floor function that yields the greatest integer less than or equal to the argument, and\n```\nlog\n      \n        2\n      \n    \n  \n\n{\\textstyle \\log _{2}}\n```\nis the binary logarithm. This is because the worst case is reached when the search reaches the deepest level of the tree, and there are always\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\nlevels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. If\n```\nn\n  \n\n{\\textstyle n}\n```\nis one less than a power of two, then this is always the case. Otherwise, the search may perform", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nIn terms of the number of comparisons, the performance of binary search can be analyzed by viewing the run of the procedure on a binary tree. The root node of the tree is the middle element of the array. The middle element of the lower half is the left child node of the root, and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. Starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration.\nIn the worst case, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations of the comparison loop, where the\n```\n⌊\n    ⋅\n    ⌋\n  \n\n{\\textstyle \\lfloor \\cdot \\rfloor }\n```\nnotation denotes the floor function that yields the greatest integer less than or equal to the argument, and\n```\nlog\n      \n        2\n      \n    \n  \n\n{\\textstyle \\log _{2}}\n```\nis the binary logarithm. This is because the worst case is reached when the search reaches the deepest level of the tree, and there are always\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\nlevels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. If\n```\nn\n  \n\n{\\textstyle n}\n```\nis one less than a power of two, then this is always the case. Otherwise, the search may perform", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nIn terms of the number of comparisons, the performance of binary search can be analyzed by viewing the run of the procedure on a binary tree. The root node of the tree is the middle element of the array. The middle element of the lower half is the left child node of the root, and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. Starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration.\nIn the worst case, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations of the comparison loop, where the\n```\n⌊\n    ⋅\n    ⌋\n  \n\n{\\textstyle \\lfloor \\cdot \\rfloor }\n```\nnotation denotes the floor function that yields the greatest integer less than or equal to the argument, and\n```\nlog\n      \n        2\n      \n    \n  \n\n{\\textstyle \\log _{2}}\n```\nis the binary logarithm. This is because the worst case is reached when the search reaches the deepest level of the tree, and there are always\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\nlevels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. If\n```\nn\n  \n\n{\\textstyle n}\n```\nis one less than a power of two, then this is always the case. Otherwise, the search may perform", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nIn terms of the number of comparisons, the performance of binary search can be analyzed by viewing the run of the procedure on a binary tree. The root node of the tree is the middle element of the array. The middle element of the lower half is the left child node of the root, and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. Starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration.\nIn the worst case, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations of the comparison loop, where the\n```\n⌊\n    ⋅\n    ⌋\n  \n\n{\\textstyle \\lfloor \\cdot \\rfloor }\n```\nnotation denotes the floor function that yields the greatest integer less than or equal to the argument, and\n```\nlog\n      \n        2\n      \n    \n  \n\n{\\textstyle \\log _{2}}\n```\nis the binary logarithm. This is because the worst case is reached when the search reaches the deepest level of the tree, and there are always\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\nlevels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. If\n```\nn\n  \n\n{\\textstyle n}\n```\nis one less than a power of two, then this is always the case. Otherwise, the search may perform", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations if the search reaches the deepest level of the tree. However, it may make\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)\\rfloor }\n```\niterations, which is one less than the worst case, if the search ends at the second-deepest level of the tree.\nOn average, assuming that each element is equally likely to be searched, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```\niterations when the target element is in the array. This is approximately equal to\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    −\n    1\n  \n\n{\\displaystyle \\log _{2}(n)-1}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations if the search reaches the deepest level of the tree. However, it may make\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)\\rfloor }\n```\niterations, which is one less than the worst case, if the search ends at the second-deepest level of the tree.\nOn average, assuming that each element is equally likely to be searched, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```\niterations when the target element is in the array. This is approximately equal to\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    −\n    1\n  \n\n{\\displaystyle \\log _{2}(n)-1}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations if the search reaches the deepest level of the tree. However, it may make\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)\\rfloor }\n```\niterations, which is one less than the worst case, if the search ends at the second-deepest level of the tree.\nOn average, assuming that each element is equally likely to be searched, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```\niterations when the target element is in the array. This is approximately equal to\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    −\n    1\n  \n\n{\\displaystyle \\log _{2}(n)-1}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations if the search reaches the deepest level of the tree. However, it may make\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)\\rfloor }\n```\niterations, which is one less than the worst case, if the search ends at the second-deepest level of the tree.\nOn average, assuming that each element is equally likely to be searched, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```\niterations when the target element is in the array. This is approximately equal to\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    −\n    1\n  \n\n{\\displaystyle \\log _{2}(n)-1}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\niterations if the search reaches the deepest level of the tree. However, it may make\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)\\rfloor }\n```\niterations, which is one less than the worst case, if the search ends at the second-deepest level of the tree.\nOn average, assuming that each element is equally likely to be searched, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```\niterations when the target element is in the array. This is approximately equal to\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    −\n    1\n  \n\n{\\displaystyle \\log _{2}(n)-1}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\niterations. When the target element is not in the array, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```\niterations on average, assuming that the range between and outside elements is equally likely to be searched.\nIn the best case, where the target value is the middle element of the array, its position is returned after one iteration.\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. The comparison tree representing binary search has the fewest levels possible as every level above the lowest level of the tree is filled completely. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is worse than binary search. By dividing the array in half, binary search ensures that the size of both subarrays are as similar as possible.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\niterations. When the target element is not in the array, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```\niterations on average, assuming that the range between and outside elements is equally likely to be searched.\nIn the best case, where the target value is the middle element of the array, its position is returned after one iteration.\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. The comparison tree representing binary search has the fewest levels possible as every level above the lowest level of the tree is filled completely. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is worse than binary search. By dividing the array in half, binary search ensures that the size of both subarrays are as similar as possible.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\niterations. When the target element is not in the array, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```\niterations on average, assuming that the range between and outside elements is equally likely to be searched.\nIn the best case, where the target value is the middle element of the array, its position is returned after one iteration.\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. The comparison tree representing binary search has the fewest levels possible as every level above the lowest level of the tree is filled completely. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is worse than binary search. By dividing the array in half, binary search ensures that the size of both subarrays are as similar as possible.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\niterations. When the target element is not in the array, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```\niterations on average, assuming that the range between and outside elements is equally likely to be searched.\nIn the best case, where the target value is the middle element of the array, its position is returned after one iteration.\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. The comparison tree representing binary search has the fewest levels possible as every level above the lowest level of the tree is filled completely. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is worse than binary search. By dividing the array in half, binary search ensures that the size of both subarrays are as similar as possible.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\niterations. When the target element is not in the array, binary search makes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle \\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```\niterations on average, assuming that the range between and outside elements is equally likely to be searched.\nIn the best case, where the target value is the middle element of the array, its position is returned after one iteration.\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. The comparison tree representing binary search has the fewest levels possible as every level above the lowest level of the tree is filled completely. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is worse than binary search. By dividing the array in half, binary search ensures that the size of both subarrays are as similar as possible.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nSpace complexity\nBinary search requires three pointers to elements, which may be array indices or pointers to memory locations, regardless of the size of the array. Therefore, the space complexity of binary search is\n```\nO\n    (\n    1\n    )\n  \n\n{\\displaystyle O(1)}\n```\nin the word RAM model of computation.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nSpace complexity\nBinary search requires three pointers to elements, which may be array indices or pointers to memory locations, regardless of the size of the array. Therefore, the space complexity of binary search is\n```\nO\n    (\n    1\n    )\n  \n\n{\\displaystyle O(1)}\n```\nin the word RAM model of computation.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nSpace complexity\nBinary search requires three pointers to elements, which may be array indices or pointers to memory locations, regardless of the size of the array. Therefore, the space complexity of binary search is\n```\nO\n    (\n    1\n    )\n  \n\n{\\displaystyle O(1)}\n```\nin the word RAM model of computation.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nSpace complexity\nBinary search requires three pointers to elements, which may be array indices or pointers to memory locations, regardless of the size of the array. Therefore, the space complexity of binary search is\n```\nO\n    (\n    1\n    )\n  \n\n{\\displaystyle O(1)}\n```\nin the word RAM model of computation.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nSpace complexity\nBinary search requires three pointers to elements, which may be array indices or pointers to memory locations, regardless of the size of the array. Therefore, the space complexity of binary search is\n```\nO\n    (\n    1\n    )\n  \n\n{\\displaystyle O(1)}\n```\nin the word RAM model of computation.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nThe average number of iterations performed by binary search depends on the probability of each element being searched. The average case is different for successful searches and unsuccessful searches. It will be assumed that each element is equally likely to be searched for successful searches. For unsuccessful searches, it will be assumed that the intervals between and outside elements are equally likely to be searched. The average case for successful searches is the number of iterations required to search every element exactly once, divided by\n```\nn\n  \n\n{\\displaystyle n}\n```\n, the number of elements. The average case for unsuccessful searches is the number of iterations required to search an element within every interval exactly once, divided by the\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nintervals.\n=### Successful searches=\nIn the binary tree representation, a successful search can be represented by a path from the root to the target node, called an internal path. The length of a path is the number of edges (connections between nodes) that the path passes through. The number of iterations performed by a search, given that the corresponding path has length l, is\n```\nl\n    +\n    1\n  \n\n{\\displaystyle l+1}\n```\ncounting the initial iteration. The internal path length is the sum of the lengths of all unique internal paths. Since there is only one path from the root to any single node, each internal path represents a search for a specific element. If there are n elements, which is a positive integer, and the internal path length is\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n, then the average number of iterations for a successful search\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          I\n          (\n          n\n          )\n        \n        n\n      \n    \n  \n\n{\\displaystyle T(n)=1+{\\frac {I(n)}{n}}}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nThe average number of iterations performed by binary search depends on the probability of each element being searched. The average case is different for successful searches and unsuccessful searches. It will be assumed that each element is equally likely to be searched for successful searches. For unsuccessful searches, it will be assumed that the intervals between and outside elements are equally likely to be searched. The average case for successful searches is the number of iterations required to search every element exactly once, divided by\n```\nn\n  \n\n{\\displaystyle n}\n```\n, the number of elements. The average case for unsuccessful searches is the number of iterations required to search an element within every interval exactly once, divided by the\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nintervals.\n=### Successful searches=\nIn the binary tree representation, a successful search can be represented by a path from the root to the target node, called an internal path. The length of a path is the number of edges (connections between nodes) that the path passes through. The number of iterations performed by a search, given that the corresponding path has length l, is\n```\nl\n    +\n    1\n  \n\n{\\displaystyle l+1}\n```\ncounting the initial iteration. The internal path length is the sum of the lengths of all unique internal paths. Since there is only one path from the root to any single node, each internal path represents a search for a specific element. If there are n elements, which is a positive integer, and the internal path length is\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n, then the average number of iterations for a successful search\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          I\n          (\n          n\n          )\n        \n        n\n      \n    \n  \n\n{\\displaystyle T(n)=1+{\\frac {I(n)}{n}}}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nThe average number of iterations performed by binary search depends on the probability of each element being searched. The average case is different for successful searches and unsuccessful searches. It will be assumed that each element is equally likely to be searched for successful searches. For unsuccessful searches, it will be assumed that the intervals between and outside elements are equally likely to be searched. The average case for successful searches is the number of iterations required to search every element exactly once, divided by\n```\nn\n  \n\n{\\displaystyle n}\n```\n, the number of elements. The average case for unsuccessful searches is the number of iterations required to search an element within every interval exactly once, divided by the\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nintervals.\n=### Successful searches=\nIn the binary tree representation, a successful search can be represented by a path from the root to the target node, called an internal path. The length of a path is the number of edges (connections between nodes) that the path passes through. The number of iterations performed by a search, given that the corresponding path has length l, is\n```\nl\n    +\n    1\n  \n\n{\\displaystyle l+1}\n```\ncounting the initial iteration. The internal path length is the sum of the lengths of all unique internal paths. Since there is only one path from the root to any single node, each internal path represents a search for a specific element. If there are n elements, which is a positive integer, and the internal path length is\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n, then the average number of iterations for a successful search\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          I\n          (\n          n\n          )\n        \n        n\n      \n    \n  \n\n{\\displaystyle T(n)=1+{\\frac {I(n)}{n}}}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nThe average number of iterations performed by binary search depends on the probability of each element being searched. The average case is different for successful searches and unsuccessful searches. It will be assumed that each element is equally likely to be searched for successful searches. For unsuccessful searches, it will be assumed that the intervals between and outside elements are equally likely to be searched. The average case for successful searches is the number of iterations required to search every element exactly once, divided by\n```\nn\n  \n\n{\\displaystyle n}\n```\n, the number of elements. The average case for unsuccessful searches is the number of iterations required to search an element within every interval exactly once, divided by the\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nintervals.\n=### Successful searches=\nIn the binary tree representation, a successful search can be represented by a path from the root to the target node, called an internal path. The length of a path is the number of edges (connections between nodes) that the path passes through. The number of iterations performed by a search, given that the corresponding path has length l, is\n```\nl\n    +\n    1\n  \n\n{\\displaystyle l+1}\n```\ncounting the initial iteration. The internal path length is the sum of the lengths of all unique internal paths. Since there is only one path from the root to any single node, each internal path represents a search for a specific element. If there are n elements, which is a positive integer, and the internal path length is\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n, then the average number of iterations for a successful search\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          I\n          (\n          n\n          )\n        \n        n\n      \n    \n  \n\n{\\displaystyle T(n)=1+{\\frac {I(n)}{n}}}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nThe average number of iterations performed by binary search depends on the probability of each element being searched. The average case is different for successful searches and unsuccessful searches. It will be assumed that each element is equally likely to be searched for successful searches. For unsuccessful searches, it will be assumed that the intervals between and outside elements are equally likely to be searched. The average case for successful searches is the number of iterations required to search every element exactly once, divided by\n```\nn\n  \n\n{\\displaystyle n}\n```\n, the number of elements. The average case for unsuccessful searches is the number of iterations required to search an element within every interval exactly once, divided by the\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nintervals.\n=### Successful searches=\nIn the binary tree representation, a successful search can be represented by a path from the root to the target node, called an internal path. The length of a path is the number of edges (connections between nodes) that the path passes through. The number of iterations performed by a search, given that the corresponding path has length l, is\n```\nl\n    +\n    1\n  \n\n{\\displaystyle l+1}\n```\ncounting the initial iteration. The internal path length is the sum of the lengths of all unique internal paths. Since there is only one path from the root to any single node, each internal path represents a search for a specific element. If there are n elements, which is a positive integer, and the internal path length is\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n, then the average number of iterations for a successful search\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          I\n          (\n          n\n          )\n        \n        n\n      \n    \n  \n\n{\\displaystyle T(n)=1+{\\frac {I(n)}{n}}}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n, with the one iteration added to count the initial iteration.\nSince binary search is the optimal algorithm for searching with comparisons, this problem is reduced to calculating the minimum internal path length of all binary trees with n nodes, which is equal to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor }\n```\nFor example, in a 7-element array, the root requires one iteration, the two elements below the root require two iterations, and the four elements below require three iterations. In this case, the internal path length is:\n```\n∑\n      \n        k\n        =\n        1\n      \n      \n        7\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    0\n    +\n    2\n    (\n    1\n    )\n    +\n    4\n    (\n    2\n    )\n    =\n    2\n    +\n    8\n    =\n    10\n  \n\n{\\displaystyle \\sum _{k=1}^{7}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =0+2(1)+4(2)=2+8=10}\n```\nThe average number of iterations would be", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n, with the one iteration added to count the initial iteration.\nSince binary search is the optimal algorithm for searching with comparisons, this problem is reduced to calculating the minimum internal path length of all binary trees with n nodes, which is equal to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor }\n```\nFor example, in a 7-element array, the root requires one iteration, the two elements below the root require two iterations, and the four elements below require three iterations. In this case, the internal path length is:\n```\n∑\n      \n        k\n        =\n        1\n      \n      \n        7\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    0\n    +\n    2\n    (\n    1\n    )\n    +\n    4\n    (\n    2\n    )\n    =\n    2\n    +\n    8\n    =\n    10\n  \n\n{\\displaystyle \\sum _{k=1}^{7}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =0+2(1)+4(2)=2+8=10}\n```\nThe average number of iterations would be", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n, with the one iteration added to count the initial iteration.\nSince binary search is the optimal algorithm for searching with comparisons, this problem is reduced to calculating the minimum internal path length of all binary trees with n nodes, which is equal to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor }\n```\nFor example, in a 7-element array, the root requires one iteration, the two elements below the root require two iterations, and the four elements below require three iterations. In this case, the internal path length is:\n```\n∑\n      \n        k\n        =\n        1\n      \n      \n        7\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    0\n    +\n    2\n    (\n    1\n    )\n    +\n    4\n    (\n    2\n    )\n    =\n    2\n    +\n    8\n    =\n    10\n  \n\n{\\displaystyle \\sum _{k=1}^{7}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =0+2(1)+4(2)=2+8=10}\n```\nThe average number of iterations would be", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n, with the one iteration added to count the initial iteration.\nSince binary search is the optimal algorithm for searching with comparisons, this problem is reduced to calculating the minimum internal path length of all binary trees with n nodes, which is equal to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor }\n```\nFor example, in a 7-element array, the root requires one iteration, the two elements below the root require two iterations, and the four elements below require three iterations. In this case, the internal path length is:\n```\n∑\n      \n        k\n        =\n        1\n      \n      \n        7\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    0\n    +\n    2\n    (\n    1\n    )\n    +\n    4\n    (\n    2\n    )\n    =\n    2\n    +\n    8\n    =\n    10\n  \n\n{\\displaystyle \\sum _{k=1}^{7}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =0+2(1)+4(2)=2+8=10}\n```\nThe average number of iterations would be", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n, with the one iteration added to count the initial iteration.\nSince binary search is the optimal algorithm for searching with comparisons, this problem is reduced to calculating the minimum internal path length of all binary trees with n nodes, which is equal to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor }\n```\nFor example, in a 7-element array, the root requires one iteration, the two elements below the root require two iterations, and the four elements below require three iterations. In this case, the internal path length is:\n```\n∑\n      \n        k\n        =\n        1\n      \n      \n        7\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    0\n    +\n    2\n    (\n    1\n    )\n    +\n    4\n    (\n    2\n    )\n    =\n    2\n    +\n    8\n    =\n    10\n  \n\n{\\displaystyle \\sum _{k=1}^{7}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =0+2(1)+4(2)=2+8=10}\n```\nThe average number of iterations would be", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n1\n    +\n    \n      \n        10\n        7\n      \n    \n    =\n    2\n    \n      \n        3\n        7\n      \n    \n  \n\n{\\displaystyle 1+{\\frac {10}{7}}=2{\\frac {3}{7}}}\n```\nbased on the equation for the average case. The sum for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ncan be simplified to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    (\n    n\n    +\n    1\n    )\n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        +\n        1\n        )\n      \n      ⌋\n    \n    −\n    \n      2\n      \n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    +\n    2\n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}\n```\nSubstituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ninto the equation for", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n1\n    +\n    \n      \n        10\n        7\n      \n    \n    =\n    2\n    \n      \n        3\n        7\n      \n    \n  \n\n{\\displaystyle 1+{\\frac {10}{7}}=2{\\frac {3}{7}}}\n```\nbased on the equation for the average case. The sum for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ncan be simplified to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    (\n    n\n    +\n    1\n    )\n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        +\n        1\n        )\n      \n      ⌋\n    \n    −\n    \n      2\n      \n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    +\n    2\n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}\n```\nSubstituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ninto the equation for", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n1\n    +\n    \n      \n        10\n        7\n      \n    \n    =\n    2\n    \n      \n        3\n        7\n      \n    \n  \n\n{\\displaystyle 1+{\\frac {10}{7}}=2{\\frac {3}{7}}}\n```\nbased on the equation for the average case. The sum for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ncan be simplified to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    (\n    n\n    +\n    1\n    )\n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        +\n        1\n        )\n      \n      ⌋\n    \n    −\n    \n      2\n      \n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    +\n    2\n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}\n```\nSubstituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ninto the equation for", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n1\n    +\n    \n      \n        10\n        7\n      \n    \n    =\n    2\n    \n      \n        3\n        7\n      \n    \n  \n\n{\\displaystyle 1+{\\frac {10}{7}}=2{\\frac {3}{7}}}\n```\nbased on the equation for the average case. The sum for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ncan be simplified to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    (\n    n\n    +\n    1\n    )\n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        +\n        1\n        )\n      \n      ⌋\n    \n    −\n    \n      2\n      \n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    +\n    2\n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}\n```\nSubstituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ninto the equation for", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n1\n    +\n    \n      \n        10\n        7\n      \n    \n    =\n    2\n    \n      \n        3\n        7\n      \n    \n  \n\n{\\displaystyle 1+{\\frac {10}{7}}=2{\\frac {3}{7}}}\n```\nbased on the equation for the average case. The sum for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ncan be simplified to:\n```\nI\n    (\n    n\n    )\n    =\n    \n      ∑\n      \n        k\n        =\n        1\n      \n      \n        n\n      \n    \n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        k\n        )\n      \n      ⌋\n    \n    =\n    (\n    n\n    +\n    1\n    )\n    \n      ⌊\n      \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        +\n        1\n        )\n      \n      ⌋\n    \n    −\n    \n      2\n      \n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    +\n    2\n  \n\n{\\displaystyle I(n)=\\sum _{k=1}^{n}\\left\\lfloor \\log _{2}(k)\\right\\rfloor =(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}\n```\nSubstituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\ninto the equation for", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)}\n```\n:", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)}\n```\n:", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)}\n```\n:", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)}\n```\n:", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n  \n\n{\\displaystyle T(n)}\n```\n:", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          \n            ⌊\n            \n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              +\n              1\n              )\n            \n            ⌋\n          \n          −\n          \n            2\n            \n              \n                ⌊\n                \n                  \n                    log\n                    \n                      2\n                    \n                  \n                  ⁡\n                  (\n                  n\n                  +\n                  1\n                  )\n                \n                ⌋\n              \n              +\n              1\n            \n          \n          +\n          2\n        \n        n\n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle T(n)=1+{\\frac {(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}{n}}=\\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          \n            ⌊\n            \n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              +\n              1\n              )\n            \n            ⌋\n          \n          −\n          \n            2\n            \n              \n                ⌊\n                \n                  \n                    log\n                    \n                      2\n                    \n                  \n                  ⁡\n                  (\n                  n\n                  +\n                  1\n                  )\n                \n                ⌋\n              \n              +\n              1\n            \n          \n          +\n          2\n        \n        n\n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle T(n)=1+{\\frac {(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}{n}}=\\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          \n            ⌊\n            \n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              +\n              1\n              )\n            \n            ⌋\n          \n          −\n          \n            2\n            \n              \n                ⌊\n                \n                  \n                    log\n                    \n                      2\n                    \n                  \n                  ⁡\n                  (\n                  n\n                  +\n                  1\n                  )\n                \n                ⌋\n              \n              +\n              1\n            \n          \n          +\n          2\n        \n        n\n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle T(n)=1+{\\frac {(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}{n}}=\\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          \n            ⌊\n            \n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              +\n              1\n              )\n            \n            ⌋\n          \n          −\n          \n            2\n            \n              \n                ⌊\n                \n                  \n                    log\n                    \n                      2\n                    \n                  \n                  ⁡\n                  (\n                  n\n                  +\n                  1\n                  )\n                \n                ⌋\n              \n              +\n              1\n            \n          \n          +\n          2\n        \n        n\n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle T(n)=1+{\\frac {(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}{n}}=\\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nT\n    (\n    n\n    )\n    =\n    1\n    +\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          \n            ⌊\n            \n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              +\n              1\n              )\n            \n            ⌋\n          \n          −\n          \n            2\n            \n              \n                ⌊\n                \n                  \n                    log\n                    \n                      2\n                    \n                  \n                  ⁡\n                  (\n                  n\n                  +\n                  1\n                  )\n                \n                ⌋\n              \n              +\n              1\n            \n          \n          +\n          2\n        \n        n\n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    1\n    −\n    (\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    −\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    −\n    2\n    )\n    \n      /\n    \n    n\n  \n\n{\\displaystyle T(n)=1+{\\frac {(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2}{n}}=\\lfloor \\log _{2}(n)\\rfloor +1-(2^{\\lfloor \\log _{2}(n)\\rfloor +1}-\\lfloor \\log _{2}(n)\\rfloor -2)/n}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nFor integer n, this is equivalent to the equation for the average case on a successful search specified above.\n=### Unsuccessful searches=\nUnsuccessful searches can be represented by augmenting the tree with external nodes, which forms an extended binary tree. If an internal node, or a node present in the tree, has fewer than two child nodes, then additional child nodes, called external nodes, are added so that each internal node has two children. By doing so, an unsuccessful search can be represented as a path to an external node, whose parent is the single element that remains during the last iteration. An external path is a path from the root to an external node. The external path length is the sum of the lengths of all unique external paths. If there are\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements, which is a positive integer, and the external path length is\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```\n, then the average number of iterations for an unsuccessful search\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          E\n          (\n          n\n          )\n        \n        \n          n\n          +\n          1\n        \n      \n    \n  \n\n{\\displaystyle T'(n)={\\frac {E(n)}{n+1}}}\n```\n, with the one iteration added to count the initial iteration. The external path length is divided by\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\ninstead of\n```\nn\n  \n\n{\\displaystyle n}\n```\nbecause there are\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nexternal paths, representing the intervals between and outside the elements of the array.\nThis problem can similarly be reduced to determining the minimum external path length of all binary trees with\n```\nn\n  \n\n{\\displaystyle n}\n```\nnodes. For all binary trees, the external path length is equal to the internal path length plus", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nFor integer n, this is equivalent to the equation for the average case on a successful search specified above.\n=### Unsuccessful searches=\nUnsuccessful searches can be represented by augmenting the tree with external nodes, which forms an extended binary tree. If an internal node, or a node present in the tree, has fewer than two child nodes, then additional child nodes, called external nodes, are added so that each internal node has two children. By doing so, an unsuccessful search can be represented as a path to an external node, whose parent is the single element that remains during the last iteration. An external path is a path from the root to an external node. The external path length is the sum of the lengths of all unique external paths. If there are\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements, which is a positive integer, and the external path length is\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```\n, then the average number of iterations for an unsuccessful search\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          E\n          (\n          n\n          )\n        \n        \n          n\n          +\n          1\n        \n      \n    \n  \n\n{\\displaystyle T'(n)={\\frac {E(n)}{n+1}}}\n```\n, with the one iteration added to count the initial iteration. The external path length is divided by\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\ninstead of\n```\nn\n  \n\n{\\displaystyle n}\n```\nbecause there are\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nexternal paths, representing the intervals between and outside the elements of the array.\nThis problem can similarly be reduced to determining the minimum external path length of all binary trees with\n```\nn\n  \n\n{\\displaystyle n}\n```\nnodes. For all binary trees, the external path length is equal to the internal path length plus", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nFor integer n, this is equivalent to the equation for the average case on a successful search specified above.\n=### Unsuccessful searches=\nUnsuccessful searches can be represented by augmenting the tree with external nodes, which forms an extended binary tree. If an internal node, or a node present in the tree, has fewer than two child nodes, then additional child nodes, called external nodes, are added so that each internal node has two children. By doing so, an unsuccessful search can be represented as a path to an external node, whose parent is the single element that remains during the last iteration. An external path is a path from the root to an external node. The external path length is the sum of the lengths of all unique external paths. If there are\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements, which is a positive integer, and the external path length is\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```\n, then the average number of iterations for an unsuccessful search\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          E\n          (\n          n\n          )\n        \n        \n          n\n          +\n          1\n        \n      \n    \n  \n\n{\\displaystyle T'(n)={\\frac {E(n)}{n+1}}}\n```\n, with the one iteration added to count the initial iteration. The external path length is divided by\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\ninstead of\n```\nn\n  \n\n{\\displaystyle n}\n```\nbecause there are\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nexternal paths, representing the intervals between and outside the elements of the array.\nThis problem can similarly be reduced to determining the minimum external path length of all binary trees with\n```\nn\n  \n\n{\\displaystyle n}\n```\nnodes. For all binary trees, the external path length is equal to the internal path length plus", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nFor integer n, this is equivalent to the equation for the average case on a successful search specified above.\n=### Unsuccessful searches=\nUnsuccessful searches can be represented by augmenting the tree with external nodes, which forms an extended binary tree. If an internal node, or a node present in the tree, has fewer than two child nodes, then additional child nodes, called external nodes, are added so that each internal node has two children. By doing so, an unsuccessful search can be represented as a path to an external node, whose parent is the single element that remains during the last iteration. An external path is a path from the root to an external node. The external path length is the sum of the lengths of all unique external paths. If there are\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements, which is a positive integer, and the external path length is\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```\n, then the average number of iterations for an unsuccessful search\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          E\n          (\n          n\n          )\n        \n        \n          n\n          +\n          1\n        \n      \n    \n  \n\n{\\displaystyle T'(n)={\\frac {E(n)}{n+1}}}\n```\n, with the one iteration added to count the initial iteration. The external path length is divided by\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\ninstead of\n```\nn\n  \n\n{\\displaystyle n}\n```\nbecause there are\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nexternal paths, representing the intervals between and outside the elements of the array.\nThis problem can similarly be reduced to determining the minimum external path length of all binary trees with\n```\nn\n  \n\n{\\displaystyle n}\n```\nnodes. For all binary trees, the external path length is equal to the internal path length plus", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\nFor integer n, this is equivalent to the equation for the average case on a successful search specified above.\n=### Unsuccessful searches=\nUnsuccessful searches can be represented by augmenting the tree with external nodes, which forms an extended binary tree. If an internal node, or a node present in the tree, has fewer than two child nodes, then additional child nodes, called external nodes, are added so that each internal node has two children. By doing so, an unsuccessful search can be represented as a path to an external node, whose parent is the single element that remains during the last iteration. An external path is a path from the root to an external node. The external path length is the sum of the lengths of all unique external paths. If there are\n```\nn\n  \n\n{\\displaystyle n}\n```\nelements, which is a positive integer, and the external path length is\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```\n, then the average number of iterations for an unsuccessful search\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          E\n          (\n          n\n          )\n        \n        \n          n\n          +\n          1\n        \n      \n    \n  \n\n{\\displaystyle T'(n)={\\frac {E(n)}{n+1}}}\n```\n, with the one iteration added to count the initial iteration. The external path length is divided by\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\ninstead of\n```\nn\n  \n\n{\\displaystyle n}\n```\nbecause there are\n```\nn\n    +\n    1\n  \n\n{\\displaystyle n+1}\n```\nexternal paths, representing the intervals between and outside the elements of the array.\nThis problem can similarly be reduced to determining the minimum external path length of all binary trees with\n```\nn\n  \n\n{\\displaystyle n}\n```\nnodes. For all binary trees, the external path length is equal to the internal path length plus", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n2\n    n\n  \n\n{\\displaystyle 2n}\n```\n. Substituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n:", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n2\n    n\n  \n\n{\\displaystyle 2n}\n```\n. Substituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n:", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n2\n    n\n  \n\n{\\displaystyle 2n}\n```\n. Substituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n:", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n2\n    n\n  \n\n{\\displaystyle 2n}\n```\n. Substituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n:", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\n2\n    n\n  \n\n{\\displaystyle 2n}\n```\n. Substituting the equation for\n```\nI\n    (\n    n\n    )\n  \n\n{\\displaystyle I(n)}\n```\n:", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nE\n    (\n    n\n    )\n    =\n    I\n    (\n    n\n    )\n    +\n    2\n    n\n    =\n    \n      [\n      \n        (\n        n\n        +\n        1\n        )\n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        −\n        \n          2\n          \n            \n              ⌊\n              \n                \n                  log\n                  \n                    2\n                  \n                \n                ⁡\n                (\n                n\n                +\n                1\n                )\n              \n              ⌋\n            \n            +\n            1\n          \n        \n        +\n        2\n      \n      ]\n    \n    +\n    2\n    n\n    =\n    (\n    n\n    +\n    1\n    )\n    (\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    )\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n  \n\n{\\displaystyle E(n)=I(n)+2n=\\left[(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2\\right]+2n=(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}\n```\nSubstituting the equation for\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nE\n    (\n    n\n    )\n    =\n    I\n    (\n    n\n    )\n    +\n    2\n    n\n    =\n    \n      [\n      \n        (\n        n\n        +\n        1\n        )\n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        −\n        \n          2\n          \n            \n              ⌊\n              \n                \n                  log\n                  \n                    2\n                  \n                \n                ⁡\n                (\n                n\n                +\n                1\n                )\n              \n              ⌋\n            \n            +\n            1\n          \n        \n        +\n        2\n      \n      ]\n    \n    +\n    2\n    n\n    =\n    (\n    n\n    +\n    1\n    )\n    (\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    )\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n  \n\n{\\displaystyle E(n)=I(n)+2n=\\left[(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2\\right]+2n=(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}\n```\nSubstituting the equation for\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nE\n    (\n    n\n    )\n    =\n    I\n    (\n    n\n    )\n    +\n    2\n    n\n    =\n    \n      [\n      \n        (\n        n\n        +\n        1\n        )\n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        −\n        \n          2\n          \n            \n              ⌊\n              \n                \n                  log\n                  \n                    2\n                  \n                \n                ⁡\n                (\n                n\n                +\n                1\n                )\n              \n              ⌋\n            \n            +\n            1\n          \n        \n        +\n        2\n      \n      ]\n    \n    +\n    2\n    n\n    =\n    (\n    n\n    +\n    1\n    )\n    (\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    )\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n  \n\n{\\displaystyle E(n)=I(n)+2n=\\left[(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2\\right]+2n=(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}\n```\nSubstituting the equation for\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nE\n    (\n    n\n    )\n    =\n    I\n    (\n    n\n    )\n    +\n    2\n    n\n    =\n    \n      [\n      \n        (\n        n\n        +\n        1\n        )\n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        −\n        \n          2\n          \n            \n              ⌊\n              \n                \n                  log\n                  \n                    2\n                  \n                \n                ⁡\n                (\n                n\n                +\n                1\n                )\n              \n              ⌋\n            \n            +\n            1\n          \n        \n        +\n        2\n      \n      ]\n    \n    +\n    2\n    n\n    =\n    (\n    n\n    +\n    1\n    )\n    (\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    )\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n  \n\n{\\displaystyle E(n)=I(n)+2n=\\left[(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2\\right]+2n=(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}\n```\nSubstituting the equation for\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n```\nE\n    (\n    n\n    )\n    =\n    I\n    (\n    n\n    )\n    +\n    2\n    n\n    =\n    \n      [\n      \n        (\n        n\n        +\n        1\n        )\n        \n          ⌊\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            (\n            n\n            +\n            1\n            )\n          \n          ⌋\n        \n        −\n        \n          2\n          \n            \n              ⌊\n              \n                \n                  log\n                  \n                    2\n                  \n                \n                ⁡\n                (\n                n\n                +\n                1\n                )\n              \n              ⌋\n            \n            +\n            1\n          \n        \n        +\n        2\n      \n      ]\n    \n    +\n    2\n    n\n    =\n    (\n    n\n    +\n    1\n    )\n    (\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    )\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n  \n\n{\\displaystyle E(n)=I(n)+2n=\\left[(n+1)\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor -2^{\\left\\lfloor \\log _{2}(n+1)\\right\\rfloor +1}+2\\right]+2n=(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}\n```\nSubstituting the equation for\n```\nE\n    (\n    n\n    )\n  \n\n{\\displaystyle E(n)}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\ninto the equation for\n```\nT\n      ′\n    \n    (\n    n\n    )\n  \n\n{\\displaystyle T'(n)}\n```\n, the average case for unsuccessful searches can be determined:\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          (\n          ⌊\n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n          ⌋\n          +\n          2\n          )\n          −\n          \n            2\n            \n              ⌊\n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              )\n              ⌋\n              +\n              1\n            \n          \n        \n        \n          (\n          n\n          +\n          1\n          )\n        \n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle T'(n)={\\frac {(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}{(n+1)}}=\\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\ninto the equation for\n```\nT\n      ′\n    \n    (\n    n\n    )\n  \n\n{\\displaystyle T'(n)}\n```\n, the average case for unsuccessful searches can be determined:\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          (\n          ⌊\n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n          ⌋\n          +\n          2\n          )\n          −\n          \n            2\n            \n              ⌊\n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              )\n              ⌋\n              +\n              1\n            \n          \n        \n        \n          (\n          n\n          +\n          1\n          )\n        \n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle T'(n)={\\frac {(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}{(n+1)}}=\\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\ninto the equation for\n```\nT\n      ′\n    \n    (\n    n\n    )\n  \n\n{\\displaystyle T'(n)}\n```\n, the average case for unsuccessful searches can be determined:\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          (\n          ⌊\n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n          ⌋\n          +\n          2\n          )\n          −\n          \n            2\n            \n              ⌊\n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              )\n              ⌋\n              +\n              1\n            \n          \n        \n        \n          (\n          n\n          +\n          1\n          )\n        \n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle T'(n)={\\frac {(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}{(n+1)}}=\\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\ninto the equation for\n```\nT\n      ′\n    \n    (\n    n\n    )\n  \n\n{\\displaystyle T'(n)}\n```\n, the average case for unsuccessful searches can be determined:\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          (\n          ⌊\n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n          ⌋\n          +\n          2\n          )\n          −\n          \n            2\n            \n              ⌊\n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              )\n              ⌋\n              +\n              1\n            \n          \n        \n        \n          (\n          n\n          +\n          1\n          )\n        \n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle T'(n)={\\frac {(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}{(n+1)}}=\\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\ninto the equation for\n```\nT\n      ′\n    \n    (\n    n\n    )\n  \n\n{\\displaystyle T'(n)}\n```\n, the average case for unsuccessful searches can be determined:\n```\nT\n      ′\n    \n    (\n    n\n    )\n    =\n    \n      \n        \n          (\n          n\n          +\n          1\n          )\n          (\n          ⌊\n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n          ⌋\n          +\n          2\n          )\n          −\n          \n            2\n            \n              ⌊\n              \n                log\n                \n                  2\n                \n              \n              ⁡\n              (\n              n\n              )\n              ⌋\n              +\n              1\n            \n          \n        \n        \n          (\n          n\n          +\n          1\n          )\n        \n      \n    \n    =\n    ⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    ⌋\n    +\n    2\n    −\n    \n      2\n      \n        ⌊\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        (\n        n\n        )\n        ⌋\n        +\n        1\n      \n    \n    \n      /\n    \n    (\n    n\n    +\n    1\n    )\n  \n\n{\\displaystyle T'(n)={\\frac {(n+1)(\\lfloor \\log _{2}(n)\\rfloor +2)-2^{\\lfloor \\log _{2}(n)\\rfloor +1}}{(n+1)}}=\\lfloor \\log _{2}(n)\\rfloor +2-2^{\\lfloor \\log _{2}(n)\\rfloor +1}/(n+1)}\n```", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n=### Performance of alternative procedure=\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search. On average, this eliminates half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers. However, it guarantees that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\ntimes in the worst case, the slight increase in efficiency per iteration does not compensate for the extra iteration for all but very large\n```\nn\n  \n\n{\\textstyle n}\n```\n.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n=### Performance of alternative procedure=\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search. On average, this eliminates half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers. However, it guarantees that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\ntimes in the worst case, the slight increase in efficiency per iteration does not compensate for the extra iteration for all but very large\n```\nn\n  \n\n{\\textstyle n}\n```\n.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n=### Performance of alternative procedure=\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search. On average, this eliminates half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers. However, it guarantees that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\ntimes in the worst case, the slight increase in efficiency per iteration does not compensate for the extra iteration for all but very large\n```\nn\n  \n\n{\\textstyle n}\n```\n.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n=### Performance of alternative procedure=\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search. On average, this eliminates half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers. However, it guarantees that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\ntimes in the worst case, the slight increase in efficiency per iteration does not compensate for the extra iteration for all but very large\n```\nn\n  \n\n{\\textstyle n}\n```\n.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nDerivation of average case\n=### Performance of alternative procedure=\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search. On average, this eliminates half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers. However, it guarantees that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    n\n    )\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}(n)+1\\rfloor }\n```\ntimes in the worst case, the slight increase in efficiency per iteration does not compensate for the extra iteration for all but very large\n```\nn\n  \n\n{\\textstyle n}\n```\n.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cost of comparison=\nIn analyzing the performance of binary search, another consideration is the time required to compare two elements. For integers and strings, the time required increases linearly as the encoding length (usually the number of bits) of the elements increase. For example, comparing a pair of 64-bit unsigned integers would require comparing up to double the bits as comparing a pair of 32-bit unsigned integers. The worst case is achieved when the integers are equal. This can be significant when the encoding lengths of the elements are large, such as with large integer types or long strings, which makes comparing elements expensive. Furthermore, comparing floating-point values (the most common digital representation of real numbers) is often more expensive than comparing integers or short strings.\nFast floating point comparison is possible via comparing as an integer. However, this kind of comparison forms a total order, which makes every floating-point value compare differently from each other and the same as itself. This is different from the typical comparison where -0.0 should be the same as 0.0 and NaN should not compare the same as any other value including itself.\n=### Branch prediction=\nAccording to Steel Bank Common Lisp contributor Paul Khuong, binary search leads to very few branch mispredictions despite its data-dependent nature. This is in part because most of it can be expressed as conditional moves instead of branches. The same applies to most logarithmic divide-and-conquer search algorithms.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cost of comparison=\nIn analyzing the performance of binary search, another consideration is the time required to compare two elements. For integers and strings, the time required increases linearly as the encoding length (usually the number of bits) of the elements increase. For example, comparing a pair of 64-bit unsigned integers would require comparing up to double the bits as comparing a pair of 32-bit unsigned integers. The worst case is achieved when the integers are equal. This can be significant when the encoding lengths of the elements are large, such as with large integer types or long strings, which makes comparing elements expensive. Furthermore, comparing floating-point values (the most common digital representation of real numbers) is often more expensive than comparing integers or short strings.\nFast floating point comparison is possible via comparing as an integer. However, this kind of comparison forms a total order, which makes every floating-point value compare differently from each other and the same as itself. This is different from the typical comparison where -0.0 should be the same as 0.0 and NaN should not compare the same as any other value including itself.\n=### Branch prediction=\nAccording to Steel Bank Common Lisp contributor Paul Khuong, binary search leads to very few branch mispredictions despite its data-dependent nature. This is in part because most of it can be expressed as conditional moves instead of branches. The same applies to most logarithmic divide-and-conquer search algorithms.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cost of comparison=\nIn analyzing the performance of binary search, another consideration is the time required to compare two elements. For integers and strings, the time required increases linearly as the encoding length (usually the number of bits) of the elements increase. For example, comparing a pair of 64-bit unsigned integers would require comparing up to double the bits as comparing a pair of 32-bit unsigned integers. The worst case is achieved when the integers are equal. This can be significant when the encoding lengths of the elements are large, such as with large integer types or long strings, which makes comparing elements expensive. Furthermore, comparing floating-point values (the most common digital representation of real numbers) is often more expensive than comparing integers or short strings.\nFast floating point comparison is possible via comparing as an integer. However, this kind of comparison forms a total order, which makes every floating-point value compare differently from each other and the same as itself. This is different from the typical comparison where -0.0 should be the same as 0.0 and NaN should not compare the same as any other value including itself.\n=### Branch prediction=\nAccording to Steel Bank Common Lisp contributor Paul Khuong, binary search leads to very few branch mispredictions despite its data-dependent nature. This is in part because most of it can be expressed as conditional moves instead of branches. The same applies to most logarithmic divide-and-conquer search algorithms.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cost of comparison=\nIn analyzing the performance of binary search, another consideration is the time required to compare two elements. For integers and strings, the time required increases linearly as the encoding length (usually the number of bits) of the elements increase. For example, comparing a pair of 64-bit unsigned integers would require comparing up to double the bits as comparing a pair of 32-bit unsigned integers. The worst case is achieved when the integers are equal. This can be significant when the encoding lengths of the elements are large, such as with large integer types or long strings, which makes comparing elements expensive. Furthermore, comparing floating-point values (the most common digital representation of real numbers) is often more expensive than comparing integers or short strings.\nFast floating point comparison is possible via comparing as an integer. However, this kind of comparison forms a total order, which makes every floating-point value compare differently from each other and the same as itself. This is different from the typical comparison where -0.0 should be the same as 0.0 and NaN should not compare the same as any other value including itself.\n=### Branch prediction=\nAccording to Steel Bank Common Lisp contributor Paul Khuong, binary search leads to very few branch mispredictions despite its data-dependent nature. This is in part because most of it can be expressed as conditional moves instead of branches. The same applies to most logarithmic divide-and-conquer search algorithms.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cost of comparison=\nIn analyzing the performance of binary search, another consideration is the time required to compare two elements. For integers and strings, the time required increases linearly as the encoding length (usually the number of bits) of the elements increase. For example, comparing a pair of 64-bit unsigned integers would require comparing up to double the bits as comparing a pair of 32-bit unsigned integers. The worst case is achieved when the integers are equal. This can be significant when the encoding lengths of the elements are large, such as with large integer types or long strings, which makes comparing elements expensive. Furthermore, comparing floating-point values (the most common digital representation of real numbers) is often more expensive than comparing integers or short strings.\nFast floating point comparison is possible via comparing as an integer. However, this kind of comparison forms a total order, which makes every floating-point value compare differently from each other and the same as itself. This is different from the typical comparison where -0.0 should be the same as 0.0 and NaN should not compare the same as any other value including itself.\n=### Branch prediction=\nAccording to Steel Bank Common Lisp contributor Paul Khuong, binary search leads to very few branch mispredictions despite its data-dependent nature. This is in part because most of it can be expressed as conditional moves instead of branches. The same applies to most logarithmic divide-and-conquer search algorithms.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cache usage=\nOn most computer architectures, the processor has a hardware cache separate from RAM. Since they are located within the processor itself, caches are much faster to access but usually store much less data than RAM. Therefore, most processors store memory locations that have been accessed recently, along with memory locations close to it. For example, when an array element is accessed, the element itself may be stored along with the elements that are stored close to it in RAM, making it faster to sequentially access array elements that are close in index to each other (locality of reference). On a sorted array, binary search can jump to distant memory locations if the array is large, unlike algorithms (such as linear search and linear probing in hash tables) which access elements in sequence. This adds slightly to the running time of binary search for large arrays on most systems.\nPaul Khuong has noted that binary search on large (≥ 512 KiB) arrays of exactly a power-of-two size tends to cause an additional problem with how CPU caches are implemented. Specifically, the translation lookaside buffer (TLB) is often implemented as a content-addressable memory (CAM), with the \"key\" usually being the lower bits of a requested address. When searching on an array of exactly a power-of-two size, memory address with the same lower bits tend to be accessed, causing collisions (\"aliasing\") with the \"key\" used to fetch the CAM. The typical TLB is 4-way associative, meaning it can handle at most four addresses hitting the same \"key\", after which TLB thrashing happens. (Although the other levels of CPU caches also use a similar setup, they manage smaller areas with a higher way count, usually 8 or 16, so they are less affected.) This can be prevented by offsetting the split point of the binary search so it divides at 31⁄64 instead of exactly the middle.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cache usage=\nOn most computer architectures, the processor has a hardware cache separate from RAM. Since they are located within the processor itself, caches are much faster to access but usually store much less data than RAM. Therefore, most processors store memory locations that have been accessed recently, along with memory locations close to it. For example, when an array element is accessed, the element itself may be stored along with the elements that are stored close to it in RAM, making it faster to sequentially access array elements that are close in index to each other (locality of reference). On a sorted array, binary search can jump to distant memory locations if the array is large, unlike algorithms (such as linear search and linear probing in hash tables) which access elements in sequence. This adds slightly to the running time of binary search for large arrays on most systems.\nPaul Khuong has noted that binary search on large (≥ 512 KiB) arrays of exactly a power-of-two size tends to cause an additional problem with how CPU caches are implemented. Specifically, the translation lookaside buffer (TLB) is often implemented as a content-addressable memory (CAM), with the \"key\" usually being the lower bits of a requested address. When searching on an array of exactly a power-of-two size, memory address with the same lower bits tend to be accessed, causing collisions (\"aliasing\") with the \"key\" used to fetch the CAM. The typical TLB is 4-way associative, meaning it can handle at most four addresses hitting the same \"key\", after which TLB thrashing happens. (Although the other levels of CPU caches also use a similar setup, they manage smaller areas with a higher way count, usually 8 or 16, so they are less affected.) This can be prevented by offsetting the split point of the binary search so it divides at 31⁄64 instead of exactly the middle.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cache usage=\nOn most computer architectures, the processor has a hardware cache separate from RAM. Since they are located within the processor itself, caches are much faster to access but usually store much less data than RAM. Therefore, most processors store memory locations that have been accessed recently, along with memory locations close to it. For example, when an array element is accessed, the element itself may be stored along with the elements that are stored close to it in RAM, making it faster to sequentially access array elements that are close in index to each other (locality of reference). On a sorted array, binary search can jump to distant memory locations if the array is large, unlike algorithms (such as linear search and linear probing in hash tables) which access elements in sequence. This adds slightly to the running time of binary search for large arrays on most systems.\nPaul Khuong has noted that binary search on large (≥ 512 KiB) arrays of exactly a power-of-two size tends to cause an additional problem with how CPU caches are implemented. Specifically, the translation lookaside buffer (TLB) is often implemented as a content-addressable memory (CAM), with the \"key\" usually being the lower bits of a requested address. When searching on an array of exactly a power-of-two size, memory address with the same lower bits tend to be accessed, causing collisions (\"aliasing\") with the \"key\" used to fetch the CAM. The typical TLB is 4-way associative, meaning it can handle at most four addresses hitting the same \"key\", after which TLB thrashing happens. (Although the other levels of CPU caches also use a similar setup, they manage smaller areas with a higher way count, usually 8 or 16, so they are less affected.) This can be prevented by offsetting the split point of the binary search so it divides at 31⁄64 instead of exactly the middle.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cache usage=\nOn most computer architectures, the processor has a hardware cache separate from RAM. Since they are located within the processor itself, caches are much faster to access but usually store much less data than RAM. Therefore, most processors store memory locations that have been accessed recently, along with memory locations close to it. For example, when an array element is accessed, the element itself may be stored along with the elements that are stored close to it in RAM, making it faster to sequentially access array elements that are close in index to each other (locality of reference). On a sorted array, binary search can jump to distant memory locations if the array is large, unlike algorithms (such as linear search and linear probing in hash tables) which access elements in sequence. This adds slightly to the running time of binary search for large arrays on most systems.\nPaul Khuong has noted that binary search on large (≥ 512 KiB) arrays of exactly a power-of-two size tends to cause an additional problem with how CPU caches are implemented. Specifically, the translation lookaside buffer (TLB) is often implemented as a content-addressable memory (CAM), with the \"key\" usually being the lower bits of a requested address. When searching on an array of exactly a power-of-two size, memory address with the same lower bits tend to be accessed, causing collisions (\"aliasing\") with the \"key\" used to fetch the CAM. The typical TLB is 4-way associative, meaning it can handle at most four addresses hitting the same \"key\", after which TLB thrashing happens. (Although the other levels of CPU caches also use a similar setup, they manage smaller areas with a higher way count, usually 8 or 16, so they are less affected.) This can be prevented by offsetting the split point of the binary search so it divides at 31⁄64 instead of exactly the middle.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nPerformance\nAdditional considerations\n=### Cache usage=\nOn most computer architectures, the processor has a hardware cache separate from RAM. Since they are located within the processor itself, caches are much faster to access but usually store much less data than RAM. Therefore, most processors store memory locations that have been accessed recently, along with memory locations close to it. For example, when an array element is accessed, the element itself may be stored along with the elements that are stored close to it in RAM, making it faster to sequentially access array elements that are close in index to each other (locality of reference). On a sorted array, binary search can jump to distant memory locations if the array is large, unlike algorithms (such as linear search and linear probing in hash tables) which access elements in sequence. This adds slightly to the running time of binary search for large arrays on most systems.\nPaul Khuong has noted that binary search on large (≥ 512 KiB) arrays of exactly a power-of-two size tends to cause an additional problem with how CPU caches are implemented. Specifically, the translation lookaside buffer (TLB) is often implemented as a content-addressable memory (CAM), with the \"key\" usually being the lower bits of a requested address. When searching on an array of exactly a power-of-two size, memory address with the same lower bits tend to be accessed, causing collisions (\"aliasing\") with the \"key\" used to fetch the CAM. The typical TLB is 4-way associative, meaning it can handle at most four addresses hitting the same \"key\", after which TLB thrashing happens. (Although the other levels of CPU caches also use a similar setup, they manage smaller areas with a higher way count, usually 8 or 16, so they are less affected.) This can be prevented by offsetting the split point of the binary search so it divides at 31⁄64 instead of exactly the middle.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking\n```\nO\n    (\n    n\n    )\n  \n\n{\\textstyle O(n)}\n```\ntime for each such operation. In addition, sorted arrays can complicate memory use especially when elements are often inserted into the array. There are other data structures that support much more efficient insertion and deletion. Binary search can be used to perform exact matching and set membership (determining whether a target value is in a collection of values). There are data structures that support faster exact matching and set membership. However, unlike many other searching schemes, binary search can be used for efficient approximate matching, usually performing such matches in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log n)}\n```\ntime regardless of the type or structure of the values themselves. In addition, there are some operations, like finding the smallest and largest element, that can be performed efficiently on a sorted array.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking\n```\nO\n    (\n    n\n    )\n  \n\n{\\textstyle O(n)}\n```\ntime for each such operation. In addition, sorted arrays can complicate memory use especially when elements are often inserted into the array. There are other data structures that support much more efficient insertion and deletion. Binary search can be used to perform exact matching and set membership (determining whether a target value is in a collection of values). There are data structures that support faster exact matching and set membership. However, unlike many other searching schemes, binary search can be used for efficient approximate matching, usually performing such matches in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log n)}\n```\ntime regardless of the type or structure of the values themselves. In addition, there are some operations, like finding the smallest and largest element, that can be performed efficiently on a sorted array.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking\n```\nO\n    (\n    n\n    )\n  \n\n{\\textstyle O(n)}\n```\ntime for each such operation. In addition, sorted arrays can complicate memory use especially when elements are often inserted into the array. There are other data structures that support much more efficient insertion and deletion. Binary search can be used to perform exact matching and set membership (determining whether a target value is in a collection of values). There are data structures that support faster exact matching and set membership. However, unlike many other searching schemes, binary search can be used for efficient approximate matching, usually performing such matches in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log n)}\n```\ntime regardless of the type or structure of the values themselves. In addition, there are some operations, like finding the smallest and largest element, that can be performed efficiently on a sorted array.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking\n```\nO\n    (\n    n\n    )\n  \n\n{\\textstyle O(n)}\n```\ntime for each such operation. In addition, sorted arrays can complicate memory use especially when elements are often inserted into the array. There are other data structures that support much more efficient insertion and deletion. Binary search can be used to perform exact matching and set membership (determining whether a target value is in a collection of values). There are data structures that support faster exact matching and set membership. However, unlike many other searching schemes, binary search can be used for efficient approximate matching, usually performing such matches in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log n)}\n```\ntime regardless of the type or structure of the values themselves. In addition, there are some operations, like finding the smallest and largest element, that can be performed efficiently on a sorted array.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking\n```\nO\n    (\n    n\n    )\n  \n\n{\\textstyle O(n)}\n```\ntime for each such operation. In addition, sorted arrays can complicate memory use especially when elements are often inserted into the array. There are other data structures that support much more efficient insertion and deletion. Binary search can be used to perform exact matching and set membership (determining whether a target value is in a collection of values). There are data structures that support faster exact matching and set membership. However, unlike many other searching schemes, binary search can be used for efficient approximate matching, usually performing such matches in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log n)}\n```\ntime regardless of the type or structure of the values themselves. In addition, there are some operations, like finding the smallest and largest element, that can be performed efficiently on a sorted array.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nLinear search\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short, although the array needs to be sorted beforehand. All sorting algorithms based on comparing elements, such as quicksort and merge sort, require at least\n```\nO\n    (\n    n\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(n\\log n)}\n```\ncomparisons in the worst case. Unlike linear search, binary search can be used for efficient approximate matching. There are operations such as finding the smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nLinear search\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short, although the array needs to be sorted beforehand. All sorting algorithms based on comparing elements, such as quicksort and merge sort, require at least\n```\nO\n    (\n    n\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(n\\log n)}\n```\ncomparisons in the worst case. Unlike linear search, binary search can be used for efficient approximate matching. There are operations such as finding the smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nLinear search\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short, although the array needs to be sorted beforehand. All sorting algorithms based on comparing elements, such as quicksort and merge sort, require at least\n```\nO\n    (\n    n\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(n\\log n)}\n```\ncomparisons in the worst case. Unlike linear search, binary search can be used for efficient approximate matching. There are operations such as finding the smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nLinear search\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short, although the array needs to be sorted beforehand. All sorting algorithms based on comparing elements, such as quicksort and merge sort, require at least\n```\nO\n    (\n    n\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(n\\log n)}\n```\ncomparisons in the worst case. Unlike linear search, binary search can be used for efficient approximate matching. There are operations such as finding the smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nLinear search\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short, although the array needs to be sorted beforehand. All sorting algorithms based on comparing elements, such as quicksort and merge sort, require at least\n```\nO\n    (\n    n\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(n\\log n)}\n```\ncomparisons in the worst case. Unlike linear search, binary search can be used for efficient approximate matching. There are operations such as finding the smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nTrees\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This even applies to balanced binary search trees, binary search trees that balance their own nodes, because they rarely produce the tree with the fewest possible levels. Except for balanced binary search trees, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching\n```\nn\n  \n\n{\\textstyle n}\n```\ncomparisons. Binary search trees take more space than sorted arrays.\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can be efficiently structured in filesystems. The B-tree generalizes this method of tree organization. B-trees are frequently used to organize long-term storage such as databases and filesystems.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nTrees\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This even applies to balanced binary search trees, binary search trees that balance their own nodes, because they rarely produce the tree with the fewest possible levels. Except for balanced binary search trees, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching\n```\nn\n  \n\n{\\textstyle n}\n```\ncomparisons. Binary search trees take more space than sorted arrays.\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can be efficiently structured in filesystems. The B-tree generalizes this method of tree organization. B-trees are frequently used to organize long-term storage such as databases and filesystems.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nTrees\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This even applies to balanced binary search trees, binary search trees that balance their own nodes, because they rarely produce the tree with the fewest possible levels. Except for balanced binary search trees, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching\n```\nn\n  \n\n{\\textstyle n}\n```\ncomparisons. Binary search trees take more space than sorted arrays.\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can be efficiently structured in filesystems. The B-tree generalizes this method of tree organization. B-trees are frequently used to organize long-term storage such as databases and filesystems.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nTrees\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This even applies to balanced binary search trees, binary search trees that balance their own nodes, because they rarely produce the tree with the fewest possible levels. Except for balanced binary search trees, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching\n```\nn\n  \n\n{\\textstyle n}\n```\ncomparisons. Binary search trees take more space than sorted arrays.\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can be efficiently structured in filesystems. The B-tree generalizes this method of tree organization. B-trees are frequently used to organize long-term storage such as databases and filesystems.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nTrees\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This even applies to balanced binary search trees, binary search trees that balance their own nodes, because they rarely produce the tree with the fewest possible levels. Except for balanced binary search trees, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching\n```\nn\n  \n\n{\\textstyle n}\n```\ncomparisons. Binary search trees take more space than sorted arrays.\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can be efficiently structured in filesystems. The B-tree generalizes this method of tree organization. B-trees are frequently used to organize long-term storage such as databases and filesystems.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nHashing\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records. Most hash table implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. Binary search also supports approximate matches. Some operations, like finding the smallest and largest element, can be done efficiently on sorted arrays but not on hash tables.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nHashing\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records. Most hash table implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. Binary search also supports approximate matches. Some operations, like finding the smallest and largest element, can be done efficiently on sorted arrays but not on hash tables.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nHashing\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records. Most hash table implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. Binary search also supports approximate matches. Some operations, like finding the smallest and largest element, can be done efficiently on sorted arrays but not on hash tables.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nHashing\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records. Most hash table implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. Binary search also supports approximate matches. Some operations, like finding the smallest and largest element, can be done efficiently on sorted arrays but not on hash tables.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nHashing\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records. Most hash table implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. Binary search also supports approximate matches. Some operations, like finding the smallest and largest element, can be done efficiently on sorted arrays but not on hash tables.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSet membership algorithms\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership. A bit array is the simplest, useful when the range of keys is limited. It compactly stores a collection of bits, with each bit representing a single key within the range of keys. Bit arrays are very fast, requiring only\n```\nO\n    (\n    1\n    )\n  \n\n{\\textstyle O(1)}\n```\ntime.  The Judy1 type of Judy array handles 64-bit keys efficiently.\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with\n```\nk\n  \n\n{\\textstyle k}\n```\nhash functions, membership queries require only\n```\nO\n    (\n    k\n    )\n  \n\n{\\textstyle O(k)}\n```\ntime. However, Bloom filters suffer from false positives.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSet membership algorithms\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership. A bit array is the simplest, useful when the range of keys is limited. It compactly stores a collection of bits, with each bit representing a single key within the range of keys. Bit arrays are very fast, requiring only\n```\nO\n    (\n    1\n    )\n  \n\n{\\textstyle O(1)}\n```\ntime.  The Judy1 type of Judy array handles 64-bit keys efficiently.\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with\n```\nk\n  \n\n{\\textstyle k}\n```\nhash functions, membership queries require only\n```\nO\n    (\n    k\n    )\n  \n\n{\\textstyle O(k)}\n```\ntime. However, Bloom filters suffer from false positives.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSet membership algorithms\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership. A bit array is the simplest, useful when the range of keys is limited. It compactly stores a collection of bits, with each bit representing a single key within the range of keys. Bit arrays are very fast, requiring only\n```\nO\n    (\n    1\n    )\n  \n\n{\\textstyle O(1)}\n```\ntime.  The Judy1 type of Judy array handles 64-bit keys efficiently.\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with\n```\nk\n  \n\n{\\textstyle k}\n```\nhash functions, membership queries require only\n```\nO\n    (\n    k\n    )\n  \n\n{\\textstyle O(k)}\n```\ntime. However, Bloom filters suffer from false positives.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSet membership algorithms\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership. A bit array is the simplest, useful when the range of keys is limited. It compactly stores a collection of bits, with each bit representing a single key within the range of keys. Bit arrays are very fast, requiring only\n```\nO\n    (\n    1\n    )\n  \n\n{\\textstyle O(1)}\n```\ntime.  The Judy1 type of Judy array handles 64-bit keys efficiently.\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with\n```\nk\n  \n\n{\\textstyle k}\n```\nhash functions, membership queries require only\n```\nO\n    (\n    k\n    )\n  \n\n{\\textstyle O(k)}\n```\ntime. However, Bloom filters suffer from false positives.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nSet membership algorithms\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership. A bit array is the simplest, useful when the range of keys is limited. It compactly stores a collection of bits, with each bit representing a single key within the range of keys. Bit arrays are very fast, requiring only\n```\nO\n    (\n    1\n    )\n  \n\n{\\textstyle O(1)}\n```\ntime.  The Judy1 type of Judy array handles 64-bit keys efficiently.\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with\n```\nk\n  \n\n{\\textstyle k}\n```\nhash functions, membership queries require only\n```\nO\n    (\n    k\n    )\n  \n\n{\\textstyle O(k)}\n```\ntime. However, Bloom filters suffer from false positives.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nOther data structures\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. These specialized data structures are usually only faster because they take advantage of the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. As long as the keys can be ordered, these operations can always be done at least efficiently on a sorted array regardless of the keys. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nOther data structures\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. These specialized data structures are usually only faster because they take advantage of the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. As long as the keys can be ordered, these operations can always be done at least efficiently on a sorted array regardless of the keys. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nOther data structures\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. These specialized data structures are usually only faster because they take advantage of the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. As long as the keys can be ordered, these operations can always be done at least efficiently on a sorted array regardless of the keys. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nOther data structures\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. These specialized data structures are usually only faster because they take advantage of the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. As long as the keys can be ordered, these operations can always be done at least efficiently on a sorted array regardless of the keys. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nBinary search versus other schemes\nOther data structures\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. These specialized data structures are usually only faster because they take advantage of the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. As long as the keys can be ordered, these operations can always be done at least efficiently on a sorted array regardless of the keys. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nUniform binary search\nUniform binary search stores, instead of the lower and upper bounds, the difference in the index of the middle element from the current iteration to the next iteration. A lookup table containing the differences is computed beforehand. For example, if the array to be searched is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) would be 6. In this case, the middle element of the left subarray ([1, 2, 3, 4, 5]) is 3 and the middle element of the right subarray ([7, 8, 9, 10, 11]) is 9. Uniform binary search would store the value of 3 as both indices differ from 6 by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the index of the middle element. Uniform binary search may be faster on systems where it is inefficient to calculate the midpoint, such as on decimal computers.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nUniform binary search\nUniform binary search stores, instead of the lower and upper bounds, the difference in the index of the middle element from the current iteration to the next iteration. A lookup table containing the differences is computed beforehand. For example, if the array to be searched is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) would be 6. In this case, the middle element of the left subarray ([1, 2, 3, 4, 5]) is 3 and the middle element of the right subarray ([7, 8, 9, 10, 11]) is 9. Uniform binary search would store the value of 3 as both indices differ from 6 by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the index of the middle element. Uniform binary search may be faster on systems where it is inefficient to calculate the midpoint, such as on decimal computers.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nUniform binary search\nUniform binary search stores, instead of the lower and upper bounds, the difference in the index of the middle element from the current iteration to the next iteration. A lookup table containing the differences is computed beforehand. For example, if the array to be searched is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) would be 6. In this case, the middle element of the left subarray ([1, 2, 3, 4, 5]) is 3 and the middle element of the right subarray ([7, 8, 9, 10, 11]) is 9. Uniform binary search would store the value of 3 as both indices differ from 6 by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the index of the middle element. Uniform binary search may be faster on systems where it is inefficient to calculate the midpoint, such as on decimal computers.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nUniform binary search\nUniform binary search stores, instead of the lower and upper bounds, the difference in the index of the middle element from the current iteration to the next iteration. A lookup table containing the differences is computed beforehand. For example, if the array to be searched is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) would be 6. In this case, the middle element of the left subarray ([1, 2, 3, 4, 5]) is 3 and the middle element of the right subarray ([7, 8, 9, 10, 11]) is 9. Uniform binary search would store the value of 3 as both indices differ from 6 by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the index of the middle element. Uniform binary search may be faster on systems where it is inefficient to calculate the midpoint, such as on decimal computers.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nUniform binary search\nUniform binary search stores, instead of the lower and upper bounds, the difference in the index of the middle element from the current iteration to the next iteration. A lookup table containing the differences is computed beforehand. For example, if the array to be searched is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], the middle element (\n```\nm\n  \n\n{\\displaystyle m}\n```\n) would be 6. In this case, the middle element of the left subarray ([1, 2, 3, 4, 5]) is 3 and the middle element of the right subarray ([7, 8, 9, 10, 11]) is 9. Uniform binary search would store the value of 3 as both indices differ from 6 by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the index of the middle element. Uniform binary search may be faster on systems where it is inefficient to calculate the midpoint, such as on decimal computers.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nExponential search\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x+1\\rfloor }\n```\niterations before binary search is started and at most\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x\\rfloor }\n```\niterations of the binary search, where\n```\nx\n  \n\n{\\textstyle x}\n```\nis the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nExponential search\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x+1\\rfloor }\n```\niterations before binary search is started and at most\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x\\rfloor }\n```\niterations of the binary search, where\n```\nx\n  \n\n{\\textstyle x}\n```\nis the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nExponential search\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x+1\\rfloor }\n```\niterations before binary search is started and at most\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x\\rfloor }\n```\niterations of the binary search, where\n```\nx\n  \n\n{\\textstyle x}\n```\nis the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nExponential search\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x+1\\rfloor }\n```\niterations before binary search is started and at most\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x\\rfloor }\n```\niterations of the binary search, where\n```\nx\n  \n\n{\\textstyle x}\n```\nis the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nExponential search\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x+1\\rfloor }\n```\niterations before binary search is started and at most\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    x\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}x\\rfloor }\n```\niterations of the binary search, where\n```\nx\n  \n\n{\\textstyle x}\n```\nis the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nInterpolation search\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array.\nA common interpolation function is linear interpolation. If\n```\nA\n  \n\n{\\displaystyle A}\n```\nis the array,\n```\nL\n    ,\n    R\n  \n\n{\\displaystyle L,R}\n```\nare the lower and upper bounds respectively, and\n```\nT\n  \n\n{\\displaystyle T}\n```\nis the target, then the target is estimated to be about\n```\n(\n    T\n    −\n    \n      A\n      \n        L\n      \n    \n    )\n    \n      /\n    \n    (\n    \n      A\n      \n        R\n      \n    \n    −\n    \n      A\n      \n        L\n      \n    \n    )\n  \n\n{\\displaystyle (T-A_{L})/(A_{R}-A_{L})}\n```\nof the way between\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. When linear interpolation is used, and the distribution of the array elements is uniform or near uniform, interpolation search makes\n```\nO\n    (\n    log\n    ⁡\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log \\log n)}\n```\ncomparisons.\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Its time complexity grows more slowly than binary search, but this only compensates for the extra computation for large arrays.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nInterpolation search\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array.\nA common interpolation function is linear interpolation. If\n```\nA\n  \n\n{\\displaystyle A}\n```\nis the array,\n```\nL\n    ,\n    R\n  \n\n{\\displaystyle L,R}\n```\nare the lower and upper bounds respectively, and\n```\nT\n  \n\n{\\displaystyle T}\n```\nis the target, then the target is estimated to be about\n```\n(\n    T\n    −\n    \n      A\n      \n        L\n      \n    \n    )\n    \n      /\n    \n    (\n    \n      A\n      \n        R\n      \n    \n    −\n    \n      A\n      \n        L\n      \n    \n    )\n  \n\n{\\displaystyle (T-A_{L})/(A_{R}-A_{L})}\n```\nof the way between\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. When linear interpolation is used, and the distribution of the array elements is uniform or near uniform, interpolation search makes\n```\nO\n    (\n    log\n    ⁡\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log \\log n)}\n```\ncomparisons.\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Its time complexity grows more slowly than binary search, but this only compensates for the extra computation for large arrays.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nInterpolation search\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array.\nA common interpolation function is linear interpolation. If\n```\nA\n  \n\n{\\displaystyle A}\n```\nis the array,\n```\nL\n    ,\n    R\n  \n\n{\\displaystyle L,R}\n```\nare the lower and upper bounds respectively, and\n```\nT\n  \n\n{\\displaystyle T}\n```\nis the target, then the target is estimated to be about\n```\n(\n    T\n    −\n    \n      A\n      \n        L\n      \n    \n    )\n    \n      /\n    \n    (\n    \n      A\n      \n        R\n      \n    \n    −\n    \n      A\n      \n        L\n      \n    \n    )\n  \n\n{\\displaystyle (T-A_{L})/(A_{R}-A_{L})}\n```\nof the way between\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. When linear interpolation is used, and the distribution of the array elements is uniform or near uniform, interpolation search makes\n```\nO\n    (\n    log\n    ⁡\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log \\log n)}\n```\ncomparisons.\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Its time complexity grows more slowly than binary search, but this only compensates for the extra computation for large arrays.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nInterpolation search\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array.\nA common interpolation function is linear interpolation. If\n```\nA\n  \n\n{\\displaystyle A}\n```\nis the array,\n```\nL\n    ,\n    R\n  \n\n{\\displaystyle L,R}\n```\nare the lower and upper bounds respectively, and\n```\nT\n  \n\n{\\displaystyle T}\n```\nis the target, then the target is estimated to be about\n```\n(\n    T\n    −\n    \n      A\n      \n        L\n      \n    \n    )\n    \n      /\n    \n    (\n    \n      A\n      \n        R\n      \n    \n    −\n    \n      A\n      \n        L\n      \n    \n    )\n  \n\n{\\displaystyle (T-A_{L})/(A_{R}-A_{L})}\n```\nof the way between\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. When linear interpolation is used, and the distribution of the array elements is uniform or near uniform, interpolation search makes\n```\nO\n    (\n    log\n    ⁡\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log \\log n)}\n```\ncomparisons.\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Its time complexity grows more slowly than binary search, but this only compensates for the extra computation for large arrays.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nInterpolation search\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array.\nA common interpolation function is linear interpolation. If\n```\nA\n  \n\n{\\displaystyle A}\n```\nis the array,\n```\nL\n    ,\n    R\n  \n\n{\\displaystyle L,R}\n```\nare the lower and upper bounds respectively, and\n```\nT\n  \n\n{\\displaystyle T}\n```\nis the target, then the target is estimated to be about\n```\n(\n    T\n    −\n    \n      A\n      \n        L\n      \n    \n    )\n    \n      /\n    \n    (\n    \n      A\n      \n        R\n      \n    \n    −\n    \n      A\n      \n        L\n      \n    \n    )\n  \n\n{\\displaystyle (T-A_{L})/(A_{R}-A_{L})}\n```\nof the way between\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\n. When linear interpolation is used, and the distribution of the array elements is uniform or near uniform, interpolation search makes\n```\nO\n    (\n    log\n    ⁡\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(\\log \\log n)}\n```\ncomparisons.\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Its time complexity grows more slowly than binary search, but this only compensates for the extra computation for large arrays.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nFractional cascading\nFractional cascading is a technique that speeds up binary searches for the same element in multiple sorted arrays. Searching each array separately requires\n```\nO\n    (\n    k\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k\\log n)}\n```\ntime, where\n```\nk\n  \n\n{\\textstyle k}\n```\nis the number of arrays. Fractional cascading reduces this to\n```\nO\n    (\n    k\n    +\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k+\\log n)}\n```\nby storing specific information in each array about each element and its position in the other arrays.\nFractional cascading was originally developed to efficiently solve various computational geometry problems. Fractional cascading has been applied elsewhere, such as in data mining and Internet Protocol routing.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nFractional cascading\nFractional cascading is a technique that speeds up binary searches for the same element in multiple sorted arrays. Searching each array separately requires\n```\nO\n    (\n    k\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k\\log n)}\n```\ntime, where\n```\nk\n  \n\n{\\textstyle k}\n```\nis the number of arrays. Fractional cascading reduces this to\n```\nO\n    (\n    k\n    +\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k+\\log n)}\n```\nby storing specific information in each array about each element and its position in the other arrays.\nFractional cascading was originally developed to efficiently solve various computational geometry problems. Fractional cascading has been applied elsewhere, such as in data mining and Internet Protocol routing.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nFractional cascading\nFractional cascading is a technique that speeds up binary searches for the same element in multiple sorted arrays. Searching each array separately requires\n```\nO\n    (\n    k\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k\\log n)}\n```\ntime, where\n```\nk\n  \n\n{\\textstyle k}\n```\nis the number of arrays. Fractional cascading reduces this to\n```\nO\n    (\n    k\n    +\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k+\\log n)}\n```\nby storing specific information in each array about each element and its position in the other arrays.\nFractional cascading was originally developed to efficiently solve various computational geometry problems. Fractional cascading has been applied elsewhere, such as in data mining and Internet Protocol routing.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nFractional cascading\nFractional cascading is a technique that speeds up binary searches for the same element in multiple sorted arrays. Searching each array separately requires\n```\nO\n    (\n    k\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k\\log n)}\n```\ntime, where\n```\nk\n  \n\n{\\textstyle k}\n```\nis the number of arrays. Fractional cascading reduces this to\n```\nO\n    (\n    k\n    +\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k+\\log n)}\n```\nby storing specific information in each array about each element and its position in the other arrays.\nFractional cascading was originally developed to efficiently solve various computational geometry problems. Fractional cascading has been applied elsewhere, such as in data mining and Internet Protocol routing.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nFractional cascading\nFractional cascading is a technique that speeds up binary searches for the same element in multiple sorted arrays. Searching each array separately requires\n```\nO\n    (\n    k\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k\\log n)}\n```\ntime, where\n```\nk\n  \n\n{\\textstyle k}\n```\nis the number of arrays. Fractional cascading reduces this to\n```\nO\n    (\n    k\n    +\n    log\n    ⁡\n    n\n    )\n  \n\n{\\textstyle O(k+\\log n)}\n```\nby storing specific information in each array about each element and its position in the other arrays.\nFractional cascading was originally developed to efficiently solve various computational geometry problems. Fractional cascading has been applied elsewhere, such as in data mining and Internet Protocol routing.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nGeneralization to graphs\nBinary search has been generalized to work on certain types of graphs, where the target value is stored in a vertex instead of an array element. Binary search trees are one such generalization—when a vertex (node) in the tree is queried, the algorithm either learns that the vertex is the target, or otherwise which subtree the target would be located in. However, this can be further generalized as follows: given an undirected, positively weighted graph and a target vertex, the algorithm learns upon querying a vertex that it is equal to the target, or it is given an incident edge that is on the shortest path from the queried vertex to the target. The standard binary search algorithm is simply the case where the graph is a path. Similarly, binary search trees are the case where the edges to the left or right subtrees are given when the queried vertex is unequal to the target. For all undirected, positively weighted graphs, there is an algorithm that finds the target vertex in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\nqueries in the worst case.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nGeneralization to graphs\nBinary search has been generalized to work on certain types of graphs, where the target value is stored in a vertex instead of an array element. Binary search trees are one such generalization—when a vertex (node) in the tree is queried, the algorithm either learns that the vertex is the target, or otherwise which subtree the target would be located in. However, this can be further generalized as follows: given an undirected, positively weighted graph and a target vertex, the algorithm learns upon querying a vertex that it is equal to the target, or it is given an incident edge that is on the shortest path from the queried vertex to the target. The standard binary search algorithm is simply the case where the graph is a path. Similarly, binary search trees are the case where the edges to the left or right subtrees are given when the queried vertex is unequal to the target. For all undirected, positively weighted graphs, there is an algorithm that finds the target vertex in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\nqueries in the worst case.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nGeneralization to graphs\nBinary search has been generalized to work on certain types of graphs, where the target value is stored in a vertex instead of an array element. Binary search trees are one such generalization—when a vertex (node) in the tree is queried, the algorithm either learns that the vertex is the target, or otherwise which subtree the target would be located in. However, this can be further generalized as follows: given an undirected, positively weighted graph and a target vertex, the algorithm learns upon querying a vertex that it is equal to the target, or it is given an incident edge that is on the shortest path from the queried vertex to the target. The standard binary search algorithm is simply the case where the graph is a path. Similarly, binary search trees are the case where the edges to the left or right subtrees are given when the queried vertex is unequal to the target. For all undirected, positively weighted graphs, there is an algorithm that finds the target vertex in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\nqueries in the worst case.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nGeneralization to graphs\nBinary search has been generalized to work on certain types of graphs, where the target value is stored in a vertex instead of an array element. Binary search trees are one such generalization—when a vertex (node) in the tree is queried, the algorithm either learns that the vertex is the target, or otherwise which subtree the target would be located in. However, this can be further generalized as follows: given an undirected, positively weighted graph and a target vertex, the algorithm learns upon querying a vertex that it is equal to the target, or it is given an incident edge that is on the shortest path from the queried vertex to the target. The standard binary search algorithm is simply the case where the graph is a path. Similarly, binary search trees are the case where the edges to the left or right subtrees are given when the queried vertex is unequal to the target. For all undirected, positively weighted graphs, there is an algorithm that finds the target vertex in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\nqueries in the worst case.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nGeneralization to graphs\nBinary search has been generalized to work on certain types of graphs, where the target value is stored in a vertex instead of an array element. Binary search trees are one such generalization—when a vertex (node) in the tree is queried, the algorithm either learns that the vertex is the target, or otherwise which subtree the target would be located in. However, this can be further generalized as follows: given an undirected, positively weighted graph and a target vertex, the algorithm learns upon querying a vertex that it is equal to the target, or it is given an incident edge that is on the shortest path from the queried vertex to the target. The standard binary search algorithm is simply the case where the graph is a path. Similarly, binary search trees are the case where the edges to the left or right subtrees are given when the queried vertex is unequal to the target. For all undirected, positively weighted graphs, there is an algorithm that finds the target vertex in\n```\nO\n    (\n    log\n    ⁡\n    n\n    )\n  \n\n{\\displaystyle O(\\log n)}\n```\nqueries in the worst case.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nNoisy binary search\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. Every noisy binary search procedure must make at least\n```\n(\n    1\n    −\n    τ\n    )\n    \n      \n        \n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n        \n        \n          H\n          (\n          p\n          )\n        \n      \n    \n    −\n    \n      \n        10\n        \n          H\n          (\n          p\n          )\n        \n      \n    \n  \n\n{\\displaystyle (1-\\tau ){\\frac {\\log _{2}(n)}{H(p)}}-{\\frac {10}{H(p)}}}\n```\ncomparisons on average, where\n```\nH\n    (\n    p\n    )\n    =\n    −\n    p\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    p\n    )\n    −\n    (\n    1\n    −\n    p\n    )\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    1\n    −\n    p\n    )\n  \n\n{\\displaystyle H(p)=-p\\log _{2}(p)-(1-p)\\log _{2}(1-p)}\n```\nis the binary entropy function and\n```\nτ\n  \n\n{\\displaystyle \\tau }\n```\nis the probability that the procedure yields the wrong position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, a variant of Twenty Questions where the answers may be wrong.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nNoisy binary search\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. Every noisy binary search procedure must make at least\n```\n(\n    1\n    −\n    τ\n    )\n    \n      \n        \n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n        \n        \n          H\n          (\n          p\n          )\n        \n      \n    \n    −\n    \n      \n        10\n        \n          H\n          (\n          p\n          )\n        \n      \n    \n  \n\n{\\displaystyle (1-\\tau ){\\frac {\\log _{2}(n)}{H(p)}}-{\\frac {10}{H(p)}}}\n```\ncomparisons on average, where\n```\nH\n    (\n    p\n    )\n    =\n    −\n    p\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    p\n    )\n    −\n    (\n    1\n    −\n    p\n    )\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    1\n    −\n    p\n    )\n  \n\n{\\displaystyle H(p)=-p\\log _{2}(p)-(1-p)\\log _{2}(1-p)}\n```\nis the binary entropy function and\n```\nτ\n  \n\n{\\displaystyle \\tau }\n```\nis the probability that the procedure yields the wrong position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, a variant of Twenty Questions where the answers may be wrong.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nNoisy binary search\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. Every noisy binary search procedure must make at least\n```\n(\n    1\n    −\n    τ\n    )\n    \n      \n        \n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n        \n        \n          H\n          (\n          p\n          )\n        \n      \n    \n    −\n    \n      \n        10\n        \n          H\n          (\n          p\n          )\n        \n      \n    \n  \n\n{\\displaystyle (1-\\tau ){\\frac {\\log _{2}(n)}{H(p)}}-{\\frac {10}{H(p)}}}\n```\ncomparisons on average, where\n```\nH\n    (\n    p\n    )\n    =\n    −\n    p\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    p\n    )\n    −\n    (\n    1\n    −\n    p\n    )\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    1\n    −\n    p\n    )\n  \n\n{\\displaystyle H(p)=-p\\log _{2}(p)-(1-p)\\log _{2}(1-p)}\n```\nis the binary entropy function and\n```\nτ\n  \n\n{\\displaystyle \\tau }\n```\nis the probability that the procedure yields the wrong position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, a variant of Twenty Questions where the answers may be wrong.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nNoisy binary search\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. Every noisy binary search procedure must make at least\n```\n(\n    1\n    −\n    τ\n    )\n    \n      \n        \n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n        \n        \n          H\n          (\n          p\n          )\n        \n      \n    \n    −\n    \n      \n        10\n        \n          H\n          (\n          p\n          )\n        \n      \n    \n  \n\n{\\displaystyle (1-\\tau ){\\frac {\\log _{2}(n)}{H(p)}}-{\\frac {10}{H(p)}}}\n```\ncomparisons on average, where\n```\nH\n    (\n    p\n    )\n    =\n    −\n    p\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    p\n    )\n    −\n    (\n    1\n    −\n    p\n    )\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    1\n    −\n    p\n    )\n  \n\n{\\displaystyle H(p)=-p\\log _{2}(p)-(1-p)\\log _{2}(1-p)}\n```\nis the binary entropy function and\n```\nτ\n  \n\n{\\displaystyle \\tau }\n```\nis the probability that the procedure yields the wrong position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, a variant of Twenty Questions where the answers may be wrong.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nNoisy binary search\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. Every noisy binary search procedure must make at least\n```\n(\n    1\n    −\n    τ\n    )\n    \n      \n        \n          \n            log\n            \n              2\n            \n          \n          ⁡\n          (\n          n\n          )\n        \n        \n          H\n          (\n          p\n          )\n        \n      \n    \n    −\n    \n      \n        10\n        \n          H\n          (\n          p\n          )\n        \n      \n    \n  \n\n{\\displaystyle (1-\\tau ){\\frac {\\log _{2}(n)}{H(p)}}-{\\frac {10}{H(p)}}}\n```\ncomparisons on average, where\n```\nH\n    (\n    p\n    )\n    =\n    −\n    p\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    p\n    )\n    −\n    (\n    1\n    −\n    p\n    )\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    (\n    1\n    −\n    p\n    )\n  \n\n{\\displaystyle H(p)=-p\\log _{2}(p)-(1-p)\\log _{2}(1-p)}\n```\nis the binary entropy function and\n```\nτ\n  \n\n{\\displaystyle \\tau }\n```\nis the probability that the procedure yields the wrong position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, a variant of Twenty Questions where the answers may be wrong.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\nClassical computers are bounded to the worst case of exactly\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}n+1\\rfloor }\n```\niterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle \\log _{2}n}\n```\nqueries (representing iterations of the classical procedure), but the constant factor is less than one, providing for a lower time complexity on quantum computers. Any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least\n```\n1\n        π\n      \n    \n    (\n    ln\n    ⁡\n    n\n    −\n    1\n    )\n    ≈\n    0.22\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle {\\frac {1}{\\pi }}(\\ln n-1)\\approx 0.22\\log _{2}n}\n```\nqueries in the worst case, where\n```\nln\n  \n\n{\\textstyle \\ln }\n```\nis the natural logarithm. There is an exact quantum binary search procedure that runs in\n```\n4\n    \n      log\n      \n        605\n      \n    \n    ⁡\n    n\n    ≈\n    0.433\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle 4\\log _{605}n\\approx 0.433\\log _{2}n}\n```\nqueries in the worst case. In comparison, Grover's algorithm is the optimal quantum algorithm for searching an unordered list of elements, and it requires", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\nClassical computers are bounded to the worst case of exactly\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}n+1\\rfloor }\n```\niterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle \\log _{2}n}\n```\nqueries (representing iterations of the classical procedure), but the constant factor is less than one, providing for a lower time complexity on quantum computers. Any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least\n```\n1\n        π\n      \n    \n    (\n    ln\n    ⁡\n    n\n    −\n    1\n    )\n    ≈\n    0.22\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle {\\frac {1}{\\pi }}(\\ln n-1)\\approx 0.22\\log _{2}n}\n```\nqueries in the worst case, where\n```\nln\n  \n\n{\\textstyle \\ln }\n```\nis the natural logarithm. There is an exact quantum binary search procedure that runs in\n```\n4\n    \n      log\n      \n        605\n      \n    \n    ⁡\n    n\n    ≈\n    0.433\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle 4\\log _{605}n\\approx 0.433\\log _{2}n}\n```\nqueries in the worst case. In comparison, Grover's algorithm is the optimal quantum algorithm for searching an unordered list of elements, and it requires", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\nClassical computers are bounded to the worst case of exactly\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}n+1\\rfloor }\n```\niterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle \\log _{2}n}\n```\nqueries (representing iterations of the classical procedure), but the constant factor is less than one, providing for a lower time complexity on quantum computers. Any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least\n```\n1\n        π\n      \n    \n    (\n    ln\n    ⁡\n    n\n    −\n    1\n    )\n    ≈\n    0.22\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle {\\frac {1}{\\pi }}(\\ln n-1)\\approx 0.22\\log _{2}n}\n```\nqueries in the worst case, where\n```\nln\n  \n\n{\\textstyle \\ln }\n```\nis the natural logarithm. There is an exact quantum binary search procedure that runs in\n```\n4\n    \n      log\n      \n        605\n      \n    \n    ⁡\n    n\n    ≈\n    0.433\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle 4\\log _{605}n\\approx 0.433\\log _{2}n}\n```\nqueries in the worst case. In comparison, Grover's algorithm is the optimal quantum algorithm for searching an unordered list of elements, and it requires", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\nClassical computers are bounded to the worst case of exactly\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}n+1\\rfloor }\n```\niterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle \\log _{2}n}\n```\nqueries (representing iterations of the classical procedure), but the constant factor is less than one, providing for a lower time complexity on quantum computers. Any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least\n```\n1\n        π\n      \n    \n    (\n    ln\n    ⁡\n    n\n    −\n    1\n    )\n    ≈\n    0.22\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle {\\frac {1}{\\pi }}(\\ln n-1)\\approx 0.22\\log _{2}n}\n```\nqueries in the worst case, where\n```\nln\n  \n\n{\\textstyle \\ln }\n```\nis the natural logarithm. There is an exact quantum binary search procedure that runs in\n```\n4\n    \n      log\n      \n        605\n      \n    \n    ⁡\n    n\n    ≈\n    0.433\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle 4\\log _{605}n\\approx 0.433\\log _{2}n}\n```\nqueries in the worst case. In comparison, Grover's algorithm is the optimal quantum algorithm for searching an unordered list of elements, and it requires", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\nClassical computers are bounded to the worst case of exactly\n```\n⌊\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n    +\n    1\n    ⌋\n  \n\n{\\textstyle \\lfloor \\log _{2}n+1\\rfloor }\n```\niterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of\n```\nlog\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle \\log _{2}n}\n```\nqueries (representing iterations of the classical procedure), but the constant factor is less than one, providing for a lower time complexity on quantum computers. Any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least\n```\n1\n        π\n      \n    \n    (\n    ln\n    ⁡\n    n\n    −\n    1\n    )\n    ≈\n    0.22\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle {\\frac {1}{\\pi }}(\\ln n-1)\\approx 0.22\\log _{2}n}\n```\nqueries in the worst case, where\n```\nln\n  \n\n{\\textstyle \\ln }\n```\nis the natural logarithm. There is an exact quantum binary search procedure that runs in\n```\n4\n    \n      log\n      \n        605\n      \n    \n    ⁡\n    n\n    ≈\n    0.433\n    \n      log\n      \n        2\n      \n    \n    ⁡\n    n\n  \n\n{\\textstyle 4\\log _{605}n\\approx 0.433\\log _{2}n}\n```\nqueries in the worst case. In comparison, Grover's algorithm is the optimal quantum algorithm for searching an unordered list of elements, and it requires", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\n```\nO\n    (\n    \n      \n        n\n      \n    \n    )\n  \n\n{\\displaystyle O({\\sqrt {n}})}\n```\nqueries.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\n```\nO\n    (\n    \n      \n        n\n      \n    \n    )\n  \n\n{\\displaystyle O({\\sqrt {n}})}\n```\nqueries.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\n```\nO\n    (\n    \n      \n        n\n      \n    \n    )\n  \n\n{\\displaystyle O({\\sqrt {n}})}\n```\nqueries.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\n```\nO\n    (\n    \n      \n        n\n      \n    \n    )\n  \n\n{\\displaystyle O({\\sqrt {n}})}\n```\nqueries.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nVariations\nQuantum binary search\n```\nO\n    (\n    \n      \n        n\n      \n    \n    )\n  \n\n{\\displaystyle O({\\sqrt {n}})}\n```\nqueries.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nHistory\nThe idea of sorting a list of items to allow for faster searching dates back to antiquity. The earliest known example was the Inakibit-Anu tablet from Babylon dating back to c. 200 BCE. The tablet contained about 500 sexagesimal numbers and their reciprocals sorted in lexicographical order, which made searching for a specific entry easier. In addition, several lists of names that were sorted by their first letter were discovered on the Aegean Islands. Catholicon, a Latin dictionary finished in 1286 CE, was the first work to describe rules for sorting words into alphabetical order, as opposed to just the first few letters.\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, a seminal and foundational college course in computing. In 1957, William Wesley Peterson published the first method for interpolation search. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was developed by A. K. Chandra of Stanford University in 1971. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nHistory\nThe idea of sorting a list of items to allow for faster searching dates back to antiquity. The earliest known example was the Inakibit-Anu tablet from Babylon dating back to c. 200 BCE. The tablet contained about 500 sexagesimal numbers and their reciprocals sorted in lexicographical order, which made searching for a specific entry easier. In addition, several lists of names that were sorted by their first letter were discovered on the Aegean Islands. Catholicon, a Latin dictionary finished in 1286 CE, was the first work to describe rules for sorting words into alphabetical order, as opposed to just the first few letters.\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, a seminal and foundational college course in computing. In 1957, William Wesley Peterson published the first method for interpolation search. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was developed by A. K. Chandra of Stanford University in 1971. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nHistory\nThe idea of sorting a list of items to allow for faster searching dates back to antiquity. The earliest known example was the Inakibit-Anu tablet from Babylon dating back to c. 200 BCE. The tablet contained about 500 sexagesimal numbers and their reciprocals sorted in lexicographical order, which made searching for a specific entry easier. In addition, several lists of names that were sorted by their first letter were discovered on the Aegean Islands. Catholicon, a Latin dictionary finished in 1286 CE, was the first work to describe rules for sorting words into alphabetical order, as opposed to just the first few letters.\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, a seminal and foundational college course in computing. In 1957, William Wesley Peterson published the first method for interpolation search. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was developed by A. K. Chandra of Stanford University in 1971. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nHistory\nThe idea of sorting a list of items to allow for faster searching dates back to antiquity. The earliest known example was the Inakibit-Anu tablet from Babylon dating back to c. 200 BCE. The tablet contained about 500 sexagesimal numbers and their reciprocals sorted in lexicographical order, which made searching for a specific entry easier. In addition, several lists of names that were sorted by their first letter were discovered on the Aegean Islands. Catholicon, a Latin dictionary finished in 1286 CE, was the first work to describe rules for sorting words into alphabetical order, as opposed to just the first few letters.\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, a seminal and foundational college course in computing. In 1957, William Wesley Peterson published the first method for interpolation search. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was developed by A. K. Chandra of Stanford University in 1971. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nHistory\nThe idea of sorting a list of items to allow for faster searching dates back to antiquity. The earliest known example was the Inakibit-Anu tablet from Babylon dating back to c. 200 BCE. The tablet contained about 500 sexagesimal numbers and their reciprocals sorted in lexicographical order, which made searching for a specific entry easier. In addition, several lists of names that were sorted by their first letter were discovered on the Aegean Islands. Catholicon, a Latin dictionary finished in 1286 CE, was the first work to describe rules for sorting words into alphabetical order, as opposed to just the first few letters.\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, a seminal and foundational college course in computing. In 1957, William Wesley Peterson published the first method for interpolation search. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was developed by A. K. Chandra of Stanford University in 1971. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\nIn a practical implementation, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as\n```\nL\n          +\n          R\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {L+R}{2}}}\n```\n, then the value of\n```\nL\n    +\n    R\n  \n\n{\\displaystyle L+R}\n```\nmay exceed the range of integers of the data type used to store the midpoint, even if\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare within the range. If\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare nonnegative, this can be avoided by calculating the midpoint as\n```\nL\n    +\n    \n      \n        \n          R\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle L+{\\frac {R-L}{2}}}\n```\n.\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once\n```\nL\n  \n\n{\\displaystyle L}\n```\nexceeds", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\nIn a practical implementation, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as\n```\nL\n          +\n          R\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {L+R}{2}}}\n```\n, then the value of\n```\nL\n    +\n    R\n  \n\n{\\displaystyle L+R}\n```\nmay exceed the range of integers of the data type used to store the midpoint, even if\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare within the range. If\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare nonnegative, this can be avoided by calculating the midpoint as\n```\nL\n    +\n    \n      \n        \n          R\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle L+{\\frac {R-L}{2}}}\n```\n.\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once\n```\nL\n  \n\n{\\displaystyle L}\n```\nexceeds", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\nIn a practical implementation, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as\n```\nL\n          +\n          R\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {L+R}{2}}}\n```\n, then the value of\n```\nL\n    +\n    R\n  \n\n{\\displaystyle L+R}\n```\nmay exceed the range of integers of the data type used to store the midpoint, even if\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare within the range. If\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare nonnegative, this can be avoided by calculating the midpoint as\n```\nL\n    +\n    \n      \n        \n          R\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle L+{\\frac {R-L}{2}}}\n```\n.\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once\n```\nL\n  \n\n{\\displaystyle L}\n```\nexceeds", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\nIn a practical implementation, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as\n```\nL\n          +\n          R\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {L+R}{2}}}\n```\n, then the value of\n```\nL\n    +\n    R\n  \n\n{\\displaystyle L+R}\n```\nmay exceed the range of integers of the data type used to store the midpoint, even if\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare within the range. If\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare nonnegative, this can be avoided by calculating the midpoint as\n```\nL\n    +\n    \n      \n        \n          R\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle L+{\\frac {R-L}{2}}}\n```\n.\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once\n```\nL\n  \n\n{\\displaystyle L}\n```\nexceeds", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\nIn a practical implementation, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as\n```\nL\n          +\n          R\n        \n        2\n      \n    \n  \n\n{\\displaystyle {\\frac {L+R}{2}}}\n```\n, then the value of\n```\nL\n    +\n    R\n  \n\n{\\displaystyle L+R}\n```\nmay exceed the range of integers of the data type used to store the midpoint, even if\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare within the range. If\n```\nL\n  \n\n{\\displaystyle L}\n```\nand\n```\nR\n  \n\n{\\displaystyle R}\n```\nare nonnegative, this can be avoided by calculating the midpoint as\n```\nL\n    +\n    \n      \n        \n          R\n          −\n          L\n        \n        2\n      \n    \n  \n\n{\\displaystyle L+{\\frac {R-L}{2}}}\n```\n.\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once\n```\nL\n  \n\n{\\displaystyle L}\n```\nexceeds", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\n```\nR\n  \n\n{\\displaystyle R}\n```\n, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that most of the programmers who incorrectly implemented binary search made an error in defining the exit conditions.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\n```\nR\n  \n\n{\\displaystyle R}\n```\n, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that most of the programmers who incorrectly implemented binary search made an error in defining the exit conditions.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\n```\nR\n  \n\n{\\displaystyle R}\n```\n, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that most of the programmers who incorrectly implemented binary search made an error in defining the exit conditions.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\n```\nR\n  \n\n{\\displaystyle R}\n```\n, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that most of the programmers who incorrectly implemented binary search made an error in defining the exit conditions.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nImplementation issues\n```\nR\n  \n\n{\\displaystyle R}\n```\n, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that most of the programmers who incorrectly implemented binary search made an error in defining the exit conditions.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nLibrary support\nMany languages' standard libraries include binary search routines:\nC provides the function bsearch() in its standard library, which is typically implemented via binary search, although the official standard does not require it so.\nC++'s standard library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\nD's standard library Phobos, in std.range module provides a type SortedRange (returned by sort() and assumeSorted() functions) with methods contains(), equaleRange(), lowerBound() and trisect(), that use binary search techniques by default for ranges that offer random access.\nCOBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\nGo's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\nJava offers a set of overloaded binarySearch() static methods in the classes Arrays and Collections in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\nMicrosoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch\n(T[] array, T value).\nFor Objective-C, the Cocoa framework provides the NSArray -indexOfObject:inSortedRange:options:usingComparator: method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a CFArrayBSearchValues() function.\nPython provides the bisect module that keeps a list in sorted order without having to sort the list after each insertion.\nRuby's Array class includes a bsearch method with built-in approximate matching.\nRust's slice primitive provides binary_search(), binary_search_by(), binary_search_by_key(), and partition_point().", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nLibrary support\nMany languages' standard libraries include binary search routines:\nC provides the function bsearch() in its standard library, which is typically implemented via binary search, although the official standard does not require it so.\nC++'s standard library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\nD's standard library Phobos, in std.range module provides a type SortedRange (returned by sort() and assumeSorted() functions) with methods contains(), equaleRange(), lowerBound() and trisect(), that use binary search techniques by default for ranges that offer random access.\nCOBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\nGo's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\nJava offers a set of overloaded binarySearch() static methods in the classes Arrays and Collections in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\nMicrosoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch\n(T[] array, T value).\nFor Objective-C, the Cocoa framework provides the NSArray -indexOfObject:inSortedRange:options:usingComparator: method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a CFArrayBSearchValues() function.\nPython provides the bisect module that keeps a list in sorted order without having to sort the list after each insertion.\nRuby's Array class includes a bsearch method with built-in approximate matching.\nRust's slice primitive provides binary_search(), binary_search_by(), binary_search_by_key(), and partition_point().", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nLibrary support\nMany languages' standard libraries include binary search routines:\nC provides the function bsearch() in its standard library, which is typically implemented via binary search, although the official standard does not require it so.\nC++'s standard library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\nD's standard library Phobos, in std.range module provides a type SortedRange (returned by sort() and assumeSorted() functions) with methods contains(), equaleRange(), lowerBound() and trisect(), that use binary search techniques by default for ranges that offer random access.\nCOBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\nGo's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\nJava offers a set of overloaded binarySearch() static methods in the classes Arrays and Collections in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\nMicrosoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch\n(T[] array, T value).\nFor Objective-C, the Cocoa framework provides the NSArray -indexOfObject:inSortedRange:options:usingComparator: method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a CFArrayBSearchValues() function.\nPython provides the bisect module that keeps a list in sorted order without having to sort the list after each insertion.\nRuby's Array class includes a bsearch method with built-in approximate matching.\nRust's slice primitive provides binary_search(), binary_search_by(), binary_search_by_key(), and partition_point().", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nLibrary support\nMany languages' standard libraries include binary search routines:\nC provides the function bsearch() in its standard library, which is typically implemented via binary search, although the official standard does not require it so.\nC++'s standard library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\nD's standard library Phobos, in std.range module provides a type SortedRange (returned by sort() and assumeSorted() functions) with methods contains(), equaleRange(), lowerBound() and trisect(), that use binary search techniques by default for ranges that offer random access.\nCOBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\nGo's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\nJava offers a set of overloaded binarySearch() static methods in the classes Arrays and Collections in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\nMicrosoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch\n(T[] array, T value).\nFor Objective-C, the Cocoa framework provides the NSArray -indexOfObject:inSortedRange:options:usingComparator: method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a CFArrayBSearchValues() function.\nPython provides the bisect module that keeps a list in sorted order without having to sort the list after each insertion.\nRuby's Array class includes a bsearch method with built-in approximate matching.\nRust's slice primitive provides binary_search(), binary_search_by(), binary_search_by_key(), and partition_point().", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nLibrary support\nMany languages' standard libraries include binary search routines:\nC provides the function bsearch() in its standard library, which is typically implemented via binary search, although the official standard does not require it so.\nC++'s standard library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\nD's standard library Phobos, in std.range module provides a type SortedRange (returned by sort() and assumeSorted() functions) with methods contains(), equaleRange(), lowerBound() and trisect(), that use binary search techniques by default for ranges that offer random access.\nCOBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\nGo's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\nJava offers a set of overloaded binarySearch() static methods in the classes Arrays and Collections in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\nMicrosoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch\n(T[] array, T value).\nFor Objective-C, the Cocoa framework provides the NSArray -indexOfObject:inSortedRange:options:usingComparator: method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a CFArrayBSearchValues() function.\nPython provides the bisect module that keeps a list in sorted order without having to sort the list after each insertion.\nRuby's Array class includes a bsearch method with built-in approximate matching.\nRust's slice primitive provides binary_search(), binary_search_by(), binary_search_by_key(), and partition_point().", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nSee also\nBisection method – Algorithm for finding a zero of a function – the same idea used to solve equations in the real numbers\nMultiplicative binary search – Binary search variation with simplified midpoint calculation", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nSee also\nBisection method – Algorithm for finding a zero of a function – the same idea used to solve equations in the real numbers\nMultiplicative binary search – Binary search variation with simplified midpoint calculation", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nSee also\nBisection method – Algorithm for finding a zero of a function – the same idea used to solve equations in the real numbers\nMultiplicative binary search – Binary search variation with simplified midpoint calculation", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nSee also\nBisection method – Algorithm for finding a zero of a function – the same idea used to solve equations in the real numbers\nMultiplicative binary search – Binary search variation with simplified midpoint calculation", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nSee also\nBisection method – Algorithm for finding a zero of a function – the same idea used to solve equations in the real numbers\nMultiplicative binary search – Binary search variation with simplified midpoint calculation", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nNotes and references\nThis article was submitted to WikiJournal of Science for external academic peer review in 2018 (reviewer reports). The updated content was reintegrated into the Wikipedia page under a CC-BY-SA-3.0 license (2019). The version of record as reviewed is:\nAnthony Lin; et al. (2 July 2019). \"Binary search algorithm\" (PDF). WikiJournal of Science. 2 (1): 5. doi:10.15347/WJS/2019.005. ISSN 2470-6345. Wikidata Q81434400.", "icl_document": "In computer science, binary search, also known as half-interval search, logarithmic search, or\nbinary chop, is a search algorithm that finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle element of the array. If they are not\nequal, the half in which the target cannot lie is eliminated and the search continues on the\nremaining half, again taking the middle element to compare to the target value, and repeating this\nuntil the target value is found. If the search ends with the remaining half being empty, the target\nis not in the array.\nBinary search runs in logarithmic time in the worst case, making O(log n) comparisons, where n is\nthe number of elements in the array. Binary search is faster than linear search except for small\narrays. However, the array must be sorted first to be able to apply binary search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is binary search?\n", "icl_response_1": "Binary search is a search algorithm that finds the position of a target value in a sorted array\nby repeatedly dividing the search interval in half. It compares the target to the middle element\nand eliminates half of the array each time.\n", "icl_query_2": "Why must the array be sorted for binary search?\n", "icl_response_2": "The array must be sorted because binary search relies on comparing the target to the middle\nelement and deciding which half to search next based on whether the target is smaller or larger,\nwhich only works if elements are in order.\n", "icl_query_3": "How does binary search compare in speed to linear search?\n", "icl_response_3": "Binary search is faster than linear search for large sorted arrays because it makes O(log n)\ncomparisons, while linear search checks every element, making O(n) comparisons. For small arrays,\nlinear search might be faster.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nNotes and references\nThis article was submitted to WikiJournal of Science for external academic peer review in 2018 (reviewer reports). The updated content was reintegrated into the Wikipedia page under a CC-BY-SA-3.0 license (2019). The version of record as reviewed is:\nAnthony Lin; et al. (2 July 2019). \"Binary search algorithm\" (PDF). WikiJournal of Science. 2 (1): 5. doi:10.15347/WJS/2019.005. ISSN 2470-6345. Wikidata Q81434400.", "icl_document": "Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of\nthe array with the target value. If the target value matches the element, its position in the array\nis returned. If the target value is less than the element, the search continues in the lower half of\nthe array. If the target value is greater than the element, the search continues in the upper half of\nthe array. By doing this, the algorithm eliminates the half in which the target value cannot lie in\neach iteration.\nGiven an array A of n elements with values or records A0, A1, A2, …, An-1 sorted such that\nA0 ≤ A1 ≤ A2 ≤ ⋯ ≤ An-1, and target value T, the following subroutine uses binary search to find the\nindex of T in A.\nSet L to 0 and R to n - 1.\nIf L > R, the search terminates as unsuccessful.\nSet m (the position of the middle element) to L plus the floor of (R - L)/2.\nIf Am < T, set L to m + 1 and go to step 2.\nIf Am > T, set R to m - 1 and go to step 2.\nNow Am = T, the search is done; return m.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What are the initial values for L and R in binary search?\n", "icl_response_1": "L is set to 0, the start of the array, and R is set to n-1, where n is the number of elements,\nrepresenting the end of the array.\n", "icl_query_2": "How is the middle element m calculated?\n", "icl_response_2": "m is calculated as L plus the floor of (R - L)/2, which finds the midpoint between L and R\nwithout risking overflow.\n", "icl_query_3": "What happens if the target is not found?\n", "icl_response_3": "If L becomes greater than R without finding the target, the search terminates as unsuccessful,\nmeaning the target is not in the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nNotes and references\nThis article was submitted to WikiJournal of Science for external academic peer review in 2018 (reviewer reports). The updated content was reintegrated into the Wikipedia page under a CC-BY-SA-3.0 license (2019). The version of record as reviewed is:\nAnthony Lin; et al. (2 July 2019). \"Binary search algorithm\" (PDF). WikiJournal of Science. 2 (1): 5. doi:10.15347/WJS/2019.005. ISSN 2470-6345. Wikidata Q81434400.", "icl_document": "function binary_search(A, n, T) is\nL := 0\nR := n - 1\nwhile L ≤ R do\nm := L + floor((R - L) / 2)\nif A[m] < T then\nL := m + 1\nelse if A[m] > T then\nR := m - 1\nelse:\nreturn m\nreturn unsuccessful\nThis iterative procedure keeps track of the search boundaries with the two variables L and R. The\nprocedure may be expressed in pseudocode as follows, where the variable names and types remain the\nsame as above, floor is the floor function, and unsuccessful refers to a specific value that conveys\nthe failure of the search.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the loop condition in the binary search pseudocode?\n", "icl_response_1": "The loop continues while L is less than or equal to R, meaning there are still elements to check\nin the current search interval.\n", "icl_query_2": "What does the code do if A[m] equals T?\n", "icl_response_2": "If A[m] equals T, it returns m, which is the index of the target value in the array.\n", "icl_query_3": "How does the code adjust the search interval if A[m] is less than T?\n", "icl_response_3": "If A[m] < T, it sets L to m + 1, so the search continues in the right half of the array.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nNotes and references\nThis article was submitted to WikiJournal of Science for external academic peer review in 2018 (reviewer reports). The updated content was reintegrated into the Wikipedia page under a CC-BY-SA-3.0 license (2019). The version of record as reviewed is:\nAnthony Lin; et al. (2 July 2019). \"Binary search algorithm\" (PDF). WikiJournal of Science. 2 (1): 5. doi:10.15347/WJS/2019.005. ISSN 2470-6345. Wikidata Q81434400.", "icl_document": "The procedure may return any index whose element is equal to the target value, even if there are\nduplicate elements in the array. For example, if the array to be searched was\n[1, 2, 3, 4, 4, 5, 6, 7] and the target was 4, then it would be correct for the algorithm to either\nreturn the 4th (index 3) or 5th (index 4) element. The regular procedure would return the 4th element\n(index 3) in this case. It does not always return the first duplicate.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "How does binary search handle duplicate elements?\n", "icl_response_1": "Binary search may return any index where the element matches the target if duplicates exist; it\ndoesn't guarantee the first or last occurrence.\n", "icl_query_2": "In the example array [1, 2, 3, 4, 4, 5, 6, 7] with target 4, what might binary search return?\n", "icl_response_2": "It could return index 3 or 4, both of which have the value 4, but the standard procedure often\nreturns index 3.\n", "icl_query_3": "Does binary search always find the first duplicate?\n", "icl_response_3": "No, it does not always return the first duplicate; it returns any matching index.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
{"document": "Binary_search\nNotes and references\nThis article was submitted to WikiJournal of Science for external academic peer review in 2018 (reviewer reports). The updated content was reintegrated into the Wikipedia page under a CC-BY-SA-3.0 license (2019). The version of record as reviewed is:\nAnthony Lin; et al. (2 July 2019). \"Binary search algorithm\" (PDF). WikiJournal of Science. 2 (1): 5. doi:10.15347/WJS/2019.005. ISSN 2470-6345. Wikidata Q81434400.", "icl_document": "In the worst case, binary search makes floor(log2(n) + 1) iterations of the comparison loop, where\nthe floor notation denotes the greatest integer less than or equal to the argument, and log2 is the\nbinary logarithm. This is because the worst case is reached when the search reaches the deepest level\nof the tree, and there are always floor(log2(n) + 1) levels in the tree for any binary search.\nThe worst case may also be reached when the target element is not in the array. On average, assuming\nthat each element is equally likely to be searched, binary search makes\nfloor(log2(n)) + 1 - (2^{floor(log2(n))+1} - floor(log2(n)) - 2)/n iterations when the target element\nis in the array. This is approximately equal to log2(n) - 1 iterations.\nIn the best case, where the target value is the middle element of the array, its position is returned\nafter one iteration.\n", "document_outline": "Overview of the binary search algorithm, including its definition, procedure, pseudocode, handling of\nduplicate elements, and basic performance characteristics.\n", "domain": "computer_science", "leaf_node_type": "knowledge", "icl_query_1": "What is the time complexity of binary search in the worst case?\n", "icl_response_1": "In the worst case, binary search takes O(log n) time, specifically floor(log2(n) + 1) comparisons.\n", "icl_query_2": "What is the best case for binary search?\n", "icl_response_2": "The best case is when the target is the middle element, requiring only one comparison.\n", "icl_query_3": "How many iterations does binary search make on average for a successful search?\n", "icl_response_3": "On average, it makes approximately log2(n) - 1 iterations for a successful search, assuming each\nelement is equally likely.\n", "leaf_node_path": "knowledge_technology_computer_science_theory_algorithms_binary_search"}
