{"document":"Linked_list\nHistory\nLinked lists were developed in 1955\u20131956, by Allen Newell, Cliff Shaw and Herbert A. Simon at RAND Corporation and Carnegie Mellon University as the primary data structure for their Information Processing Language (IPL). IPL was used by the authors to develop several early artificial intelligence programs, including the Logic Theory Machine, the General Problem Solver, and a computer chess program. Reports on their work appeared in IRE Transactions on Information Theory in 1956, and several conference proceedings from 1957 to 1959, including Proceedings of the Western Joint Computer Conference in 1957 and 1958, and Information Processing (Proceedings of the first UNESCO International Conference on Information Processing) in 1959. The now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in \"Programming the Logic Theory Machine\" by Newell and Shaw in Proc. WJCC, February 1957. Newell and Simon were recognized with the ACM Turing Award in 1975 for having \"made basic contributions to artificial intelligence, the psychology of human cognition, and list processing\". The problem of machine translation for natural language processing led Victor Yngve at Massachusetts Institute of Technology (MIT) to use linked lists as data structures in his COMIT programming language for computer research in the field of linguistics. A report on this language entitled \"A programming language for mechanical translation\" appeared in Mechanical Translation in 1958.\nAnother early appearance of linked lists was by Hans Peter Luhn who wrote an internal IBM memorandum in January 1953 that suggested the use of linked lists in chained hash tables.\nLISP, standing for list processor, was created by John McCarthy in 1958 while he was at MIT and in 1960 he published its design in a paper in the Communications of the ACM, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\". One of LISP's major data structures is the linked list.","icl_document":"A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a\ncount of the current number of elements. If the space reserved for the dynamic array is exceeded, it\nis reallocated and (possibly) copied, which is an expensive operation.\nLinked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a\nspecific point of a list, assuming that a pointer is indexed to the node (before the one to be removed,\nor before the insertion point) already, is a constant-time operation (otherwise without this reference\nit is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the\nelements on average, and all the elements in the worst case. While one can \"delete\" an element from an\narray in constant time by somehow marking its slot as \"vacant\", this causes fragmentation that impedes\nthe performance of iteration.\nMoreover, arbitrarily many elements may be inserted into a linked list, limited only by the total\nmemory available; while a dynamic array will eventually fill up its underlying array data structure\nand will have to reallocate\u2014an expensive operation, one that may not even be possible if memory is\nfragmented, although the cost of reallocation can be averaged over insertions, and the cost of an\ninsertion due to reallocation would still be amortized O(1). This helps with appending elements at the\narray's end, but inserting into (or removing from) middle positions still carries prohibitive costs due\nto data moving to maintain contiguity. An array from which many elements are removed may also have to\nbe resized in order to avoid wasting too much space.\nOn the other hand, dynamic arrays (as well as fixed-size array data structures) allow constant-time\nrandom access, while linked lists allow only sequential access to elements. Singly linked lists, in\nfact, can be easily traversed in only one direction. This makes linked lists unsuitable for\napplications where it's useful to look up an element by its index quickly, such as heapsort. Sequential\naccess on arrays and dynamic arrays is also faster than on linked lists on many machines, because they\nhave optimal locality of reference and thus make good use of data caching.\nAnother disadvantage of linked lists is the extra storage needed for references, which often makes them\nimpractical for lists of small data items such as characters or Boolean values, because the storage\noverhead for the links may exceed by a factor of two or more the size of the data. In contrast, a\ndynamic array requires only the space for the data itself (and a very small amount of control data).\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What advantage do linked lists have over dynamic arrays for insertion?\n","icl_response_1":"Insertion in linked lists is constant time if you have a pointer to the position, without needing to\nshift elements.\n","icl_query_2":"Why are dynamic arrays better for random access?\n","icl_response_2":"They allow constant-time access to any element by index, unlike linked lists which require\nsequential traversal.\n","icl_query_3":"What is a drawback of linked lists in terms of storage?\n","icl_response_3":"They need extra space for pointers, which can be inefficient for small data items.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"In which year was Linked lists first developed and by whom?\n\nA) 1953, Hans Peter Luhn at IBM\nB) 1955-1956, Allen Newell, Cliff Shaw and Herbert A. Simon at RAND Corporation and Carnegie Mellon University\nC) 1158, Victor Yngve at MIT\nD) 1960, John McCarthy at MIT","mmlubench_answer":"B) 1955-1956, Allen Newell, Cliff Shaw and Herbert A. Simon at RAND Corporation and Carnegie Mellon University","dataset_type":"mcq_qa","answer":1,"choices":["1953, Hans Peter Luhn at IBM","1955-1956, Allen Newell, Cliff Shaw and Herbert A. Simon at RAND Corporation and Carnegie Mellon University","1158, Victor Yngve at MIT","1960, John McCarthy at MIT"],"question":"In which year was Linked lists first developed and by whom?"}
{"document":"Linked_list\nBasic concepts and nomenclature\nDoubly linked list\nIn a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or 'next' and 'prev'('previous').\nA technique known as XOR-linking allows a doubly linked list to be implemented using a single link field in each node. However, this technique requires the ability to do bit operations on addresses, and therefore may not be available in some high-level languages.\nMany modern operating systems use doubly linked lists to maintain references to active processes, threads, and other dynamic objects. A common strategy for rootkits to evade detection is to unlink themselves from these lists.","icl_document":"Each record of a linked list is often called an 'element' or 'node'.\nThe field of each node that contains the address of the next node is usually called the 'next link'\nor 'next pointer'. The remaining fields are known as the 'data', 'information', 'value', 'cargo', or\n'payload' fields.\nThe 'head' of a list is its first node. The 'tail' of a list may refer either to the rest of the list\nafter the head, or to the last node in the list. In Lisp and some derived languages, the next node may\nbe called the 'cdr' (pronounced \/'k\u028ad.\u0259\u0279\/) of the list, while the payload of the head node may be called\nthe 'car'.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a node in a linked list?\n","icl_response_1":"A node is an element that contains data and a pointer to the next node.\n","icl_query_2":"What does the 'head' of a linked list refer to?\n","icl_response_2":"The head is the first node in the list.\n","icl_query_3":"What is the 'next pointer' in a node?\n","icl_response_3":"The next pointer is the field that holds the address of the following node in the sequence.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is a doubly linked list in computer science?\n\nA) A data structure where each node contains only a next-node link\nB) A data structure where each node contains only a previous-node link\nC) A data structure where each node contains both a next-and previous-node link\nD) A data structure where each node contains no links","mmlubench_answer":"C) A data structure where each node contains both a next-and previous-node link","dataset_type":"mcq_qa","answer":2,"choices":["A data structure where each node contains only a next-node link","A data structure where each node contains only a previous-node link","A data structure where each node contains both a next-and previous-node link","A data structure where each node contains no links"],"question":"What is a doubly linked list in computer science?"}
{"document":"Linked_list\nTradeoffs\nDoubly linked vs. singly linked\nDouble-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What are the advantages of using a doubly linked list over a singly linked list?\n\nA) Doubly linked lists require less space per node and have faster elementary operations.\nB) Singly linked lists allow tail-sharing and can be used as persistent data structures.\nC) Doubly linked lists are easier to manipulate and allow fast access in both directions.\nD) Singly linked lists have constant number of operations for insertion or deletion of a node.","mmlubench_answer":"C) Doubly linked lists are easier to manipulate and allow fast access in both directions.","dataset_type":"mcq_qa","answer":2,"choices":["Doubly linked lists require less space per node and have faster elementary operations.","Singly linked lists allow tail-sharing and can be used as persistent data structures.","Doubly linked lists are easier to manipulate and allow fast access in both directions.","Singly linked lists have constant number of operations for insertion or deletion of a node."],"question":"What are the advantages of using a doubly linked list over a singly linked list?"}
{"document":"Linked_list\nTradeoffs\nDoubly linked vs. singly linked\nDouble-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which disadvantage does a doubly linked list have compared to a singly linked list?\n\nA) Doubly linked lists require less space per node and have faster elementary operations.\nB) Singly linked lists allow tail-sharing and can be used as persistent data structures.\nC) Doubly linked lists are more difficult to manipulate and do not allow fast access in both directions.\nD) Doubly linked lists cannot be used with persistent data structures.","mmlubench_answer":"D) Doubly linked lists cannot be used as persistent data structures.","dataset_type":"mcq_qa","answer":3,"choices":["Doubly linked lists require less space per node and have faster elementary operations.","Singly linked lists allow tail-sharing and can be used as persistent data structures.","Doubly linked lists are more difficult to manipulate and do not allow fast access in both directions.","Doubly linked lists cannot be used with persistent data structures."],"question":"Which disadvantage does a doubly linked list have compared to a singly linked list?"}
{"document":"Linked_list\nTradeoffs\nDoubly linked vs. singly linked\nDouble-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures.","icl_document":"Each record of a linked list is often called an 'element' or 'node'.\nThe field of each node that contains the address of the next node is usually called the 'next link'\nor 'next pointer'. The remaining fields are known as the 'data', 'information', 'value', 'cargo', or\n'payload' fields.\nThe 'head' of a list is its first node. The 'tail' of a list may refer either to the rest of the list\nafter the head, or to the last node in the list. In Lisp and some derived languages, the next node may\nbe called the 'cdr' (pronounced \/'k\u028ad.\u0259\u0279\/) of the list, while the payload of the head node may be called\nthe 'car'.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a node in a linked list?\n","icl_response_1":"A node is an element that contains data and a pointer to the next node.\n","icl_query_2":"What does the 'head' of a linked list refer to?\n","icl_response_2":"The head is the first node in the list.\n","icl_query_3":"What is the 'next pointer' in a node?\n","icl_response_3":"The next pointer is the field that holds the address of the following node in the sequence.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the primary advantage of a doubly linked list compared to a singly linked list?\n\nA) Less space per node\nB) Faster elementary operations\nC) Allows tail-sharing and can be used as persistent data structures\nD) Easier manipulation in one direction only","mmlubench_answer":"B) Faster elementary operations","dataset_type":"mcq_qa","answer":1,"choices":["Less space per node","Faster elementary operations","Allows tail-sharing and can be used as persistent data structures","Easier manipulation in one direction only"],"question":"What is the primary advantage of a doubly linked list compared to a singly linked list?"}
{"document":"Linked_list\nTradeoffs\nDoubly linked vs. singly linked\nDouble-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures.","icl_document":"Each record of a linked list is often called an 'element' or 'node'.\nThe field of each node that contains the address of the next node is usually called the 'next link'\nor 'next pointer'. The remaining fields are known as the 'data', 'information', 'value', 'cargo', or\n'payload' fields.\nThe 'head' of a list is its first node. The 'tail' of a list may refer either to the rest of the list\nafter the head, or to the last node in the list. In Lisp and some derived languages, the next node may\nbe called the 'cdr' (pronounced \/'k\u028ad.\u0259\u0279\/) of the list, while the payload of the head node may be called\nthe 'car'.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a node in a linked list?\n","icl_response_1":"A node is an element that contains data and a pointer to the next node.\n","icl_query_2":"What does the 'head' of a linked list refer to?\n","icl_response_2":"The head is the first node in the list.\n","icl_query_3":"What is the 'next pointer' in a node?\n","icl_response_3":"The next pointer is the field that holds the address of the following node in the sequence.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Why is it easier to manipulate a doubly linked list compared to a singly linked list?\n\nA) It requires less space per node\nB) Elementary operations are faster\nC) It allows fast and easy sequential access in both directions\nD) It cannot be used as persistent data structures","mmlubench_answer":"C) It allows fast and easy sequential access in both directions.","dataset_type":"mcq_qa","answer":2,"choices":["It requires less space per node","Elementary operations are faster","It allows fast and easy sequential access in both directions","It cannot be used as persistent data structures"],"question":"Why is it easier to manipulate a doubly linked list compared to a singly linked list?"}
{"document":"Linked_list\nTradeoffs\nCircularly linked vs. linearly linked\nA circularly linked list may be a natural option to represent arrays that are naturally circular, e.g. the corners of a polygon, a pool of buffers that are used and released in FIFO (\"first in, first out\") order, or a set of processes that should be time-shared in round-robin order. In these applications, a pointer to any node serves as a handle to the whole list.\nWith a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two.\nA circular list can be split into two circular lists, in constant time, by giving the addresses of the last node of each piece. The operation consists in swapping the contents of the link fields of those two nodes. Applying the same operation to any two nodes in two distinct lists joins the two list into one. This property greatly simplifies some algorithms and data structures, such as the quad-edge and face-edge.\nThe simplest representation for an empty circular list (when such a thing makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty linear list is more natural and often creates fewer special cases.\nFor some applications, it can be useful to use singly linked lists that can vary between being circular and being linear, or even circular with a linear initial segment. Algorithms for searching or otherwise operating on these have to take precautions to avoid accidentally entering an endless loop. One well-known method is to have a second pointer walking the list at half or double the speed, and if both pointers meet at the same node, a cycle has been found.","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What are some applications where a circularly linked list may be a better option than a linearly linked list?\n\nA) Applications that require access to only one end of the list\nB) Applications that involve arrays that are naturally circular, such as polygons\nC) Applications that have nodes with varying circular and linear structures\nD) Applications that can be efficiently handled by a single pointer at both ends","mmlubench_answer":"D) Applications that can be efficiently handled by a single pointer at both ends","dataset_type":"mcq_qa","answer":3,"choices":["Applications that require access to only one end of the list","Applications that involve arrays that are naturally circular, such as polygons","Applications that have nodes with varying circular and linear structures","Applications that can be efficiently handled by a single pointer at both ends"],"question":"What are some applications where a circularly linked list may be a better option than a linearly linked list?"}
{"document":"Linked_list\nTradeoffs\nCircularly linked vs. linearly linked\nA circularly linked list may be a natural option to represent arrays that are naturally circular, e.g. the corners of a polygon, a pool of buffers that are used and released in FIFO (\"first in, first out\") order, or a set of processes that should be time-shared in round-robin order. In these applications, a pointer to any node serves as a handle to the whole list.\nWith a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two.\nA circular list can be split into two circular lists, in constant time, by giving the addresses of the last node of each piece. The operation consists in swapping the contents of the link fields of those two nodes. Applying the same operation to any two nodes in two distinct lists joins the two list into one. This property greatly simplifies some algorithms and data structures, such as the quad-edge and face-edge.\nThe simplest representation for an empty circular list (when such a thing makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty linear list is more natural and often creates fewer special cases.\nFor some applications, it can be useful to use singly linked lists that can vary between being circular and being linear, or even circular with a linear initial segment. Algorithms for searching or otherwise operating on these have to take precautions to avoid accidentally entering an endless loop. One well-known method is to have a second pointer walking the list at half or double the speed, and if both pointers meet at the same node, a cycle has been found.","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which method is used to detect an endless loop in algorithms for searching or operating on singly linked lists that can be circular with a linear initial segment?\n\nA) By having a second pointer walking at half the speed of the first pointer\nB) By testing for this special case and handling it separately\nC) By using a null pointer to denote an empty circular list\nD) By swapping the contents of the link fields of any two nodes in two distinct lists","mmlubench_answer":"A) By having a second pointer walking at half the speed of the first pointer","dataset_type":"mcq_qa","answer":0,"choices":["By having a second pointer walking at half the speed of the first pointer","By testing for this special case and handling it separately","By using a null pointer to denote an empty circular list","By swapping the contents of the link fields of any two nodes in two distinct lists"],"question":"Which method is used to detect an endless loop in algorithms for searching or operating on singly linked lists that can be circular with a linear initial segment?"}
{"document":"Linked_list\nLinked list operations\nLinearly linked lists\n=### Singly linked lists=\nThe node data structure will have two fields. There is also a variable, firstNode which always points to the first node in the list, or is null for an empty list.\nrecord Node\n{\ndata; \/\/ The data being stored in the node\nNode next \/\/ A reference to the next node, null for last node\n}\nrecord List\n{\nNode firstNode \/\/ points to first node of list; null for empty list\n}\nTraversal of a singly linked list is simple, beginning at the first node and following each next link until reaching the end:\nnode := list.firstNode\nwhile node not null\n(do something with node.data)\nnode := node.next\nThe following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done directly; instead, one must keep track of the previous node and insert a node after it.\nfunction insertAfter(Node node, Node newNode) \/\/ insert newNode after node\nnewNode.next := node.next\nnode.next    := newNode\nInserting at the beginning of the list requires a separate function. This requires updating firstNode.\nfunction insertBeginning(List list, Node newNode) \/\/ insert node before current first node\nnewNode.next   := list.firstNode\nlist.firstNode := newNode\nSimilarly, there are functions for removing the node after a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.\nfunction removeAfter(Node node) \/\/ remove node past this one\nobsoleteNode := node.next\nnode.next := node.next.next\ndestroy obsoleteNode\nfunction removeBeginning(List list) \/\/ remove first node\nobsoleteNode := list.firstNode\nlist.firstNode := list.firstNode.next \/\/ point past deleted node\ndestroy obsoleteNode","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the role of the 'next' variable in a singly linked list node?\n\nA) It represents the data being stored in the node\nB) It points to the next node in the list\nC) It is used for deleting a node from the list\nD) It is used for inserting a new node before an existing one","mmlubench_answer":"B) It points to the next node in the list","dataset_type":"mcq_qa","answer":1,"choices":["It represents the data being stored in the node","It points to the next node in the list","It is used for deleting a node from the list","It is used for inserting a new node before an existing one"],"question":"What is the role of the 'next' variable in a singly linked list node?"}
{"document":"Linked_list\nLinked list operations\nLinearly linked lists\n=### Singly linked lists=\nThe node data structure will have two fields. There is also a variable, firstNode which always points to the first node in the list, or is null for an empty list.\nrecord Node\n{\ndata; \/\/ The data being stored in the node\nNode next \/\/ A reference to the next node, null for last node\n}\nrecord List\n{\nNode firstNode \/\/ points to first node of list; null for empty list\n}\nTraversal of a singly linked list is simple, beginning at the first node and following each next link until reaching the end:\nnode := list.firstNode\nwhile node not null\n(do something with node.data)\nnode := node.next\nThe following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done directly; instead, one must keep track of the previous node and insert a node after it.\nfunction insertAfter(Node node, Node newNode) \/\/ insert newNode after node\nnewNode.next := node.next\nnode.next    := newNode\nInserting at the beginning of the list requires a separate function. This requires updating firstNode.\nfunction insertBeginning(List list, Node newNode) \/\/ insert node before current first node\nnewNode.next   := list.firstNode\nlist.firstNode := newNode\nSimilarly, there are functions for removing the node after a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.\nfunction removeAfter(Node node) \/\/ remove node past this one\nobsoleteNode := node.next\nnode.next := node.next.next\ndestroy obsoleteNode\nfunction removeBeginning(List list) \/\/ remove first node\nobsoleteNode := list.firstNode\nlist.firstNode := list.firstNode.next \/\/ point past deleted node\ndestroy obsoleteNode","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which function is used to delete a node from the beginning of a singly linked list?\n\nA) insertAfter\nB) removeAfter\nC) insertBeginning\nD) removeBeginning","mmlubench_answer":"C) insertBeginning","dataset_type":"mcq_qa","answer":2,"choices":["insertAfter","removeAfter","insertBeginning","removeBeginning"],"question":"Which function is used to delete a node from the beginning of a singly linked list?"}
{"document":"Linked_list\nLinked list operations\nLinearly linked lists\n=### Singly linked lists=\nThe node data structure will have two fields. There is also a variable, firstNode which always points to the first node in the list, or is null for an empty list.\nrecord Node\n{\ndata; \/\/ The data being stored in the node\nNode next \/\/ A reference to the next node, null for last node\n}\nrecord List\n{\nNode firstNode \/\/ points to first node of list; null for empty list\n}\nTraversal of a singly linked list is simple, beginning at the first node and following each next link until reaching the end:\nnode := list.firstNode\nwhile node not null\n(do something with node.data)\nnode := node.next\nThe following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done directly; instead, one must keep track of the previous node and insert a node after it.\nfunction insertAfter(Node node, Node newNode) \/\/ insert newNode after node\nnewNode.next := node.next\nnode.next    := newNode\nInserting at the beginning of the list requires a separate function. This requires updating firstNode.\nfunction insertBeginning(List list, Node newNode) \/\/ insert node before current first node\nnewNode.next   := list.firstNode\nlist.firstNode := newNode\nSimilarly, there are functions for removing the node after a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.\nfunction removeAfter(Node node) \/\/ remove node past this one\nobsoleteNode := node.next\nnode.next := node.next.next\ndestroy obsoleteNode\nfunction removeBeginning(List list) \/\/ remove first node\nobsoleteNode := list.firstNode\nlist.firstNode := list.firstNode.next \/\/ point past deleted node\ndestroy obsoleteNode","icl_document":"A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a\ncount of the current number of elements. If the space reserved for the dynamic array is exceeded, it\nis reallocated and (possibly) copied, which is an expensive operation.\nLinked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a\nspecific point of a list, assuming that a pointer is indexed to the node (before the one to be removed,\nor before the insertion point) already, is a constant-time operation (otherwise without this reference\nit is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the\nelements on average, and all the elements in the worst case. While one can \"delete\" an element from an\narray in constant time by somehow marking its slot as \"vacant\", this causes fragmentation that impedes\nthe performance of iteration.\nMoreover, arbitrarily many elements may be inserted into a linked list, limited only by the total\nmemory available; while a dynamic array will eventually fill up its underlying array data structure\nand will have to reallocate\u2014an expensive operation, one that may not even be possible if memory is\nfragmented, although the cost of reallocation can be averaged over insertions, and the cost of an\ninsertion due to reallocation would still be amortized O(1). This helps with appending elements at the\narray's end, but inserting into (or removing from) middle positions still carries prohibitive costs due\nto data moving to maintain contiguity. An array from which many elements are removed may also have to\nbe resized in order to avoid wasting too much space.\nOn the other hand, dynamic arrays (as well as fixed-size array data structures) allow constant-time\nrandom access, while linked lists allow only sequential access to elements. Singly linked lists, in\nfact, can be easily traversed in only one direction. This makes linked lists unsuitable for\napplications where it's useful to look up an element by its index quickly, such as heapsort. Sequential\naccess on arrays and dynamic arrays is also faster than on linked lists on many machines, because they\nhave optimal locality of reference and thus make good use of data caching.\nAnother disadvantage of linked lists is the extra storage needed for references, which often makes them\nimpractical for lists of small data items such as characters or Boolean values, because the storage\noverhead for the links may exceed by a factor of two or more the size of the data. In contrast, a\ndynamic array requires only the space for the data itself (and a very small amount of control data).\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What advantage do linked lists have over dynamic arrays for insertion?\n","icl_response_1":"Insertion in linked lists is constant time if you have a pointer to the position, without needing to\nshift elements.\n","icl_query_2":"Why are dynamic arrays better for random access?\n","icl_response_2":"They allow constant-time access to any element by index, unlike linked lists which require\nsequential traversal.\n","icl_query_3":"What is a drawback of linked lists in terms of storage?\n","icl_response_3":"They need extra space for pointers, which can be inefficient for small data items.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the data structure used in a singly linked list?\n\nA) Doubly linked list\nB) Circular linked list\nC) Singly linked list\nD) Stack","mmlubench_answer":"C) Singly linked list","dataset_type":"mcq_qa","answer":2,"choices":["Doubly linked list","Circular linked list","Singly linked list","Stack"],"question":"What is the data structure used in a singly linked list?"}
{"document":"Linked_list\nLinked list operations\nCircularly linked list\nIn a circularly linked list, all nodes are linked in a continuous circle, without using null. For lists with a front and a back (such as a queue), one stores a reference to the last node in the list. The next node after the last node is the first node. Elements can be added to the back of the list and removed from the front in constant time.\nCircularly linked lists can be either singly or doubly linked.\nBoth types of circularly linked lists benefit from the ability to traverse the full list beginning at any given node. This often allows us to avoid storing firstNode and lastNode, although if the list may be empty, there needs to be a special representation for the empty list, such as a lastNode variable which points to some node in the list or is null if it is empty; it uses such a lastNode here. This representation significantly simplifies adding and removing nodes with a non-empty list, but empty lists are then a special case.\n=### Algorithms=\nAssuming that someNode is some node in a non-empty circular singly linked list, this code iterates through that list starting with someNode:\nfunction iterate(someNode)\nif someNode \u2260 null\nnode := someNode\ndo\ndo something with node.value\nnode := node.next\nwhile node \u2260 someNode\nNotice that the test \"while node \u2260 someNode\" must be at the end of the loop. If the test was moved to the beginning of the loop, the procedure would fail whenever the list had only one node.\nThis function inserts a node \"newNode\" into a circular linked list after a given node \"node\". If \"node\" is null, it assumes that the list is empty.\nfunction insertAfter(Node node, Node newNode)\nif node = null    \/\/ assume list is empty\nnewNode.next := newNode\nelse\nnewNode.next := node.next\nnode.next := newNode\nupdate lastNode variable if necessary\nSuppose that \"L\" is a variable pointing to the last node of a circular linked list (or null if the list is empty). To append \"newNode\" to the end of the list, one may do","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is a circularly linked list and how does it differ from an ordinary linked list?\n\nA) A circular linked list is a type of linked list where all nodes are linked in a continuous circle, without using null. It differs from an ordinary linked list as it allows elements to be added or removed from the back and front of the list in constant time.\nB) A circular linked list is a type of linked list that can only traverse in one direction. It does not differ significantly from an ordinary linked list in terms of traversal.\nC) A circular linked list is a type of linked list where all nodes are linked to each other. It differs from an ordinary linked list as it does not store a first node or last node, simplifying adding and removing nodes with a non-empty list.\nD) A circular linked list is a type of linked list that stores data in a circular fashion. It differs from an ordinary linked list as it requires a special representation for the empty list.","mmlubench_answer":"C) A circular linked list is a type of linked list where nodes are linked in such a way that the last node's next pointer points to the first node, allowing elements to be added or removed from the back and front of the list in constant time. It differs from an ordinary linked list as it does not store a first node or last node, simplifying adding and removing nodes with a non-empty list.","dataset_type":"mcq_qa","answer":2,"choices":["A circular linked list is a type of linked list where all nodes are linked in a continuous circle, without using null. It differs from an ordinary linked list as it allows elements to be added or removed from the back and front of the list in constant time.","A circular linked list is a type of linked list that can only traverse in one direction. It does not differ significantly from an ordinary linked list in terms of traversal.","A circular linked list is a type of linked list where all nodes are linked to each other. It differs from an ordinary linked list as it does not store a first node or last node, simplifying adding and removing nodes with a non-empty list.","A circular linked list is a type of linked list that stores data in a circular fashion. It differs from an ordinary linked list as it requires a special representation for the empty list."],"question":"What is a circularly linked list and how does it differ from an ordinary linked list?"}
{"document":"Linked_list\nLinked list operations\nLinked lists using arrays of nodes\nThe linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly serialized for storage on disk or transfer over a network.\nEspecially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.\nLocality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.\nNa\u00efve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.\nSeizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.\nThis approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:\nIt increases complexity of the implementation.\nGrowing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.\nAdding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (O(n)) instead of constant time (although it is still an amortized constant).\nUsing a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.\nFor these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What are the advantages of using an array of nodes instead of dynamic memory allocation for a linked list?\n\nA) Increases implementation complexity and creates a private memory space for nodes\nB) Improves locality of reference and reduces allocation overhead per node\nC) Makes growing a large list difficult or impossible\nD) Slows down adding elements with linear time complexity","mmlubench_answer":"B) Improves locality of reference and reduces allocation overhead per node","dataset_type":"mcq_qa","answer":1,"choices":["Increases implementation complexity and creates a private memory space for nodes","Improves locality of reference and reduces allocation overhead per node","Makes growing a large list difficult or impossible","Slows down adding elements with linear time complexity"],"question":"What are the advantages of using an array of nodes instead of dynamic memory allocation for a linked list?"}
{"document":"Linked_list\nLinked list operations\nLinked lists using arrays of nodes\nThe linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly serialized for storage on disk or transfer over a network.\nEspecially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.\nLocality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.\nNa\u00efve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.\nSeizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.\nThis approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:\nIt increases complexity of the implementation.\nGrowing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.\nAdding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (O(n)) instead of constant time (although it is still an amortized constant).\nUsing a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.\nFor these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What are the main disadvantages of using an array of nodes for a linked list?\n\nA) Increases implementation complexity and creates a private memory space for nodes\nB) Improves locality of reference and reduces allocation overhead per node\nC) Makes growing a large list difficult or impossible\nD) Slows down adding elements with linear time complexity, increases the size of the implementation","mmlubench_answer":"A) Increases implementation complexity and creates a private memory space for nodes","dataset_type":"mcq_qa","answer":0,"choices":["Increases implementation complexity and creates a private memory space for nodes","Improves locality of reference and reduces allocation overhead per node","Makes growing a large list difficult or impossible","Slows down adding elements with linear time complexity, increases the size of the implementation"],"question":"What are the main disadvantages of using an array of nodes for a linked list?"}
{"document":"Linked_list\nLinked list operations\nLinked lists using arrays of nodes\nThe linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly serialized for storage on disk or transfer over a network.\nEspecially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.\nLocality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.\nNa\u00efve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.\nSeizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.\nThis approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:\nIt increases complexity of the implementation.\nGrowing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.\nAdding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (O(n)) instead of constant time (although it is still an amortized constant).\nUsing a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.\nFor these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Why is it easier to find space for a new linked list node in a large, general memory pool than growing a full array?\n\nA) Growing a full array takes linear time\nB) Finding space for a new node in a large, general memory pool requires a search for a free memory block of the desired size\nC) Adding elements to a dynamic array is an amortized constant time operation\nD) Dynamic memory allocation typically results in less overhead storage per node compared to an array of nodes","mmlubench_answer":"B) Finding space for a new node in a large, general memory pool requires a search for a free memory block of the desired size","dataset_type":"mcq_qa","answer":1,"choices":["Growing a full array takes linear time","Finding space for a new node in a large, general memory pool requires a search for a free memory block of the desired size","Adding elements to a dynamic array is an amortized constant time operation","Dynamic memory allocation typically results in less overhead storage per node compared to an array of nodes"],"question":"Why is it easier to find space for a new linked list node in a large, general memory pool than growing a full array?"}
{"document":"Linked_list\nLinked list operations\nLinked lists using arrays of nodes\nThe linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly serialized for storage on disk or transfer over a network.\nEspecially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.\nLocality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.\nNa\u00efve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.\nSeizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.\nThis approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:\nIt increases complexity of the implementation.\nGrowing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.\nAdding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (O(n)) instead of constant time (although it is still an amortized constant).\nUsing a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.\nFor these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.","icl_document":"A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a\ncount of the current number of elements. If the space reserved for the dynamic array is exceeded, it\nis reallocated and (possibly) copied, which is an expensive operation.\nLinked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a\nspecific point of a list, assuming that a pointer is indexed to the node (before the one to be removed,\nor before the insertion point) already, is a constant-time operation (otherwise without this reference\nit is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the\nelements on average, and all the elements in the worst case. While one can \"delete\" an element from an\narray in constant time by somehow marking its slot as \"vacant\", this causes fragmentation that impedes\nthe performance of iteration.\nMoreover, arbitrarily many elements may be inserted into a linked list, limited only by the total\nmemory available; while a dynamic array will eventually fill up its underlying array data structure\nand will have to reallocate\u2014an expensive operation, one that may not even be possible if memory is\nfragmented, although the cost of reallocation can be averaged over insertions, and the cost of an\ninsertion due to reallocation would still be amortized O(1). This helps with appending elements at the\narray's end, but inserting into (or removing from) middle positions still carries prohibitive costs due\nto data moving to maintain contiguity. An array from which many elements are removed may also have to\nbe resized in order to avoid wasting too much space.\nOn the other hand, dynamic arrays (as well as fixed-size array data structures) allow constant-time\nrandom access, while linked lists allow only sequential access to elements. Singly linked lists, in\nfact, can be easily traversed in only one direction. This makes linked lists unsuitable for\napplications where it's useful to look up an element by its index quickly, such as heapsort. Sequential\naccess on arrays and dynamic arrays is also faster than on linked lists on many machines, because they\nhave optimal locality of reference and thus make good use of data caching.\nAnother disadvantage of linked lists is the extra storage needed for references, which often makes them\nimpractical for lists of small data items such as characters or Boolean values, because the storage\noverhead for the links may exceed by a factor of two or more the size of the data. In contrast, a\ndynamic array requires only the space for the data itself (and a very small amount of control data).\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What advantage do linked lists have over dynamic arrays for insertion?\n","icl_response_1":"Insertion in linked lists is constant time if you have a pointer to the position, without needing to\nshift elements.\n","icl_query_2":"Why are dynamic arrays better for random access?\n","icl_response_2":"They allow constant-time access to any element by index, unlike linked lists which require\nsequential traversal.\n","icl_query_3":"What is a drawback of linked lists in terms of storage?\n","icl_response_3":"They need extra space for pointers, which can be inefficient for small data items.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the main advantage of using an array of nodes instead of dynamic memory allocation for linked lists?\n\nA) Reduces complexity of implementation\nB) Allows for easy growth of the list\nC) Eliminates the need for a private memory space for nodes\nD) Improves locality of reference","mmlubench_answer":"D) Improves locality of reference","dataset_type":"mcq_qa","answer":3,"choices":["Reduces complexity of implementation","Allows for easy growth of the list","Eliminates the need for a private memory space for nodes","Improves locality of reference"],"question":"What is the main advantage of using an array of nodes instead of dynamic memory allocation for linked lists?"}
{"document":"Linked_list\nLanguage support\nMany programming languages such as Lisp and Scheme have singly linked lists built in. In many functional languages, these lists are constructed from nodes, each called a cons or cons cell. The cons has two fields: the car, a reference to the data for that node, and the cdr, a reference to the next node. Although cons cells can be used to build other data structures, this is their primary purpose.\nIn languages that support abstract data types or templates, linked list ADTs or templates are available for building linked lists. In other languages, linked lists are typically built using references together with records.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which programming languages typically use records and references to build linked lists instead of having it as a built-in data type or using cons cells?\n\nA) Lisp\nB) Scheme\nC) C++\nD) Java","mmlubench_answer":"D) Java","dataset_type":"mcq_qa","answer":3,"choices":["Lisp","Scheme","C++","Java"],"question":"Which programming languages typically use records and references to build linked lists instead of having it as a built-in data type or using cons cells?"}
{"document":"Linked_list\nInternal and external storage\nWhen constructing a linked list, one is faced with the choice of whether to store the data of the list directly in the linked list nodes, called internal storage, or merely to store a reference to the data, called external storage. Internal storage has the advantage of making access to the data more efficient, requiring less storage overall, having better locality of reference, and simplifying memory management for the list (its data is allocated and deallocated at the same time as the list nodes).\nExternal storage, on the other hand, has the advantage of being more generic, in that the same data structure and machine code can be used for a linked list no matter what the size of the data is. It also makes it easy to place the same data in multiple linked lists. Although with internal storage the same data can be placed in multiple lists by including multiple next references in the node data structure, it would then be necessary to create separate routines to add or delete cells based on each field. It is possible to create additional linked lists of elements that use internal storage by using external storage, and having the cells of the additional linked lists store references to the nodes of the linked list containing the data.\nIn general, if a set of data structures needs to be included in linked lists, external storage is the best approach. If a set of data structures need to be included in only one linked list, then internal storage is slightly better, unless a generic linked list package using external storage is available. Likewise, if different sets of data that can be stored in the same data structure are to be included in a single linked list, then internal storage would be fine.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the advantage of using internal storage in a linked list?\n\nA) It makes it easy to place the same data in multiple linked lists.\nB) It simplifies memory management for the list.\nC) It requires less storage overall.\nD) It makes access to the data less efficient.","mmlubench_answer":"B) It simplifies memory management for the list.","dataset_type":"mcq_qa","answer":1,"choices":["It makes it easy to place the same data in multiple linked lists.","It simplifies memory management for the list.","It requires less storage overall.","It makes access to the data less efficient."],"question":"What is the advantage of using internal storage in a linked list?"}
{"document":"Linked_list\nInternal and external storage\nWhen constructing a linked list, one is faced with the choice of whether to store the data of the list directly in the linked list nodes, called internal storage, or merely to store a reference to the data, called external storage. Internal storage has the advantage of making access to the data more efficient, requiring less storage overall, having better locality of reference, and simplifying memory management for the list (its data is allocated and deallocated at the same time as the list nodes).\nExternal storage, on the other hand, has the advantage of being more generic, in that the same data structure and machine code can be used for a linked list no matter what the size of the data is. It also makes it easy to place the same data in multiple linked lists. Although with internal storage the same data can be placed in multiple lists by including multiple next references in the node data structure, it would then be necessary to create separate routines to add or delete cells based on each field. It is possible to create additional linked lists of elements that use internal storage by using external storage, and having the cells of the additional linked lists store references to the nodes of the linked list containing the data.\nIn general, if a set of data structures needs to be included in linked lists, external storage is the best approach. If a set of data structures need to be included in only one linked list, then internal storage is slightly better, unless a generic linked list package using external storage is available. Likewise, if different sets of data that can be stored in the same data structure are to be included in a single linked list, then internal storage would be fine.","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is the advantage of using internal storage in constructing a linked list?\n\nA) Makes it easier to place the same data in multiple linked lists\nB) Simplifies memory management for the list\nC) Requires less storage overall\nD) Allows for more efficient access to the data","mmlubench_answer":"B) Simplifies memory management for the list","dataset_type":"mcq_qa","answer":1,"choices":["Makes it easier to place the same data in multiple linked lists","Simplifies memory management for the list","Requires less storage overall","Allows for more efficient access to the data"],"question":"What is the advantage of using internal storage in constructing a linked list?"}
{"document":"Linked_list\nInternal and external storage\nExample of internal and external storage\nTo create a linked list of families and their members, using internal storage, the structure might look like the following:\nrecord member { \/\/ member of a family\nmember next;\nstring firstName;\ninteger age;\n}\nrecord family { \/\/ the family itself\nfamily next;\nstring lastName;\nstring address;\nmember members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using internal storage, write:\naFamily := Families \/\/ start at head of families list\nwhile aFamily \u2260 null \/\/ loop through list of families\nprint information about family\naMember := aFamily.members \/\/ get head of list of this family's members\nwhile aMember \u2260 null \/\/ loop through list of members\nprint information about member\naMember := aMember.next\naFamily := aFamily.next\nUsing external storage, the following structures can be created:\nrecord node { \/\/ generic link structure\nnode next;\npointer data \/\/ generic pointer for data at node\n}\nrecord member { \/\/ structure for family member\nstring firstName;\ninteger age\n}\nrecord family { \/\/ structure for family\nstring lastName;\nstring address;\nnode members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using external storage, write:\nfamNode := Families \/\/ start at head of families list\nwhile famNode \u2260 null \/\/ loop through list of families\naFamily := (family) famNode.data \/\/ extract family from node\nprint information about family\nmemNode := aFamily.members \/\/ get list of family members\nwhile memNode \u2260 null \/\/ loop through list of members\naMember := (member)memNode.data \/\/ extract member from node\nprint information about member\nmemNode := memNode.next\nfamNode := famNode.next","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which type of storage is used for the head of the list of members in internal storage representation?\n\nA) External\nB) Internal\nC) Digital\nD) Generic","mmlubench_answer":"B) Internal","dataset_type":"mcq_qa","answer":1,"choices":["External","Internal","Digital","Generic"],"question":"Which type of storage is used for the head of the list of members in internal storage representation?"}
{"document":"Linked_list\nInternal and external storage\nExample of internal and external storage\nTo create a linked list of families and their members, using internal storage, the structure might look like the following:\nrecord member { \/\/ member of a family\nmember next;\nstring firstName;\ninteger age;\n}\nrecord family { \/\/ the family itself\nfamily next;\nstring lastName;\nstring address;\nmember members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using internal storage, write:\naFamily := Families \/\/ start at head of families list\nwhile aFamily \u2260 null \/\/ loop through list of families\nprint information about family\naMember := aFamily.members \/\/ get head of list of this family's members\nwhile aMember \u2260 null \/\/ loop through list of members\nprint information about member\naMember := aMember.next\naFamily := aFamily.next\nUsing external storage, the following structures can be created:\nrecord node { \/\/ generic link structure\nnode next;\npointer data \/\/ generic pointer for data at node\n}\nrecord member { \/\/ structure for family member\nstring firstName;\ninteger age\n}\nrecord family { \/\/ structure for family\nstring lastName;\nstring address;\nnode members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using external storage, write:\nfamNode := Families \/\/ start at head of families list\nwhile famNode \u2260 null \/\/ loop through list of families\naFamily := (family) famNode.data \/\/ extract family from node\nprint information about family\nmemNode := aFamily.members \/\/ get list of family members\nwhile memNode \u2260 null \/\/ loop through list of members\naMember := (member)memNode.data \/\/ extract member from node\nprint information about member\nmemNode := memNode.next\nfamNode := famNode.next","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What type of data is stored in the 'data' pointer of the generic link structure in external storage representation?\n\nA) Family information\nB) Member information\nC) Next node address\nD) Record identifier","mmlubench_answer":"B) Member information","dataset_type":"mcq_qa","answer":1,"choices":["Family information","Member information","Next node address","Record identifier"],"question":"What type of data is stored in the 'data' pointer of the generic link structure in external storage representation?"}
{"document":"Linked_list\nInternal and external storage\nExample of internal and external storage\nTo create a linked list of families and their members, using internal storage, the structure might look like the following:\nrecord member { \/\/ member of a family\nmember next;\nstring firstName;\ninteger age;\n}\nrecord family { \/\/ the family itself\nfamily next;\nstring lastName;\nstring address;\nmember members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using internal storage, write:\naFamily := Families \/\/ start at head of families list\nwhile aFamily \u2260 null \/\/ loop through list of families\nprint information about family\naMember := aFamily.members \/\/ get head of list of this family's members\nwhile aMember \u2260 null \/\/ loop through list of members\nprint information about member\naMember := aMember.next\naFamily := aFamily.next\nUsing external storage, the following structures can be created:\nrecord node { \/\/ generic link structure\nnode next;\npointer data \/\/ generic pointer for data at node\n}\nrecord member { \/\/ structure for family member\nstring firstName;\ninteger age\n}\nrecord family { \/\/ structure for family\nstring lastName;\nstring address;\nnode members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using external storage, write:\nfamNode := Families \/\/ start at head of families list\nwhile famNode \u2260 null \/\/ loop through list of families\naFamily := (family) famNode.data \/\/ extract family from node\nprint information about family\nmemNode := aFamily.members \/\/ get list of family members\nwhile memNode \u2260 null \/\/ loop through list of members\naMember := (member)memNode.data \/\/ extract member from node\nprint information about member\nmemNode := memNode.next\nfamNode := famNode.next","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is used to store the head of a list of members for each family in internal storage linked list?\n\nA) record family {... member next;... members next; }\nB) record family {... record member {... next: member; }... members next: family; }\nC) record family {... record member {... next: member; }... next: family; }\nD) record family {... record member {... next: family; }... members next: member; }","mmlubench_answer":"C) record family {... next: family; ... members next: member; }","dataset_type":"mcq_qa","answer":2,"choices":["record family {... member next;... members next; }","record family {... record member {... next: member; }... members next: family; }","record family {... record member {... next: member; }... next: family; }","record family {... record member {... next: family; }... members next: member; }"],"question":"What is used to store the head of a list of members for each family in internal storage linked list?"}
{"document":"Linked_list\nInternal and external storage\nExample of internal and external storage\nTo create a linked list of families and their members, using internal storage, the structure might look like the following:\nrecord member { \/\/ member of a family\nmember next;\nstring firstName;\ninteger age;\n}\nrecord family { \/\/ the family itself\nfamily next;\nstring lastName;\nstring address;\nmember members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using internal storage, write:\naFamily := Families \/\/ start at head of families list\nwhile aFamily \u2260 null \/\/ loop through list of families\nprint information about family\naMember := aFamily.members \/\/ get head of list of this family's members\nwhile aMember \u2260 null \/\/ loop through list of members\nprint information about member\naMember := aMember.next\naFamily := aFamily.next\nUsing external storage, the following structures can be created:\nrecord node { \/\/ generic link structure\nnode next;\npointer data \/\/ generic pointer for data at node\n}\nrecord member { \/\/ structure for family member\nstring firstName;\ninteger age\n}\nrecord family { \/\/ structure for family\nstring lastName;\nstring address;\nnode members \/\/ head of list of members of this family\n}\nTo print a complete list of families and their members using external storage, write:\nfamNode := Families \/\/ start at head of families list\nwhile famNode \u2260 null \/\/ loop through list of families\naFamily := (family) famNode.data \/\/ extract family from node\nprint information about family\nmemNode := aFamily.members \/\/ get list of family members\nwhile memNode \u2260 null \/\/ loop through list of members\naMember := (member)memNode.data \/\/ extract member from node\nprint information about member\nmemNode := memNode.next\nfamNode := famNode.next","icl_document":"A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a\ncount of the current number of elements. If the space reserved for the dynamic array is exceeded, it\nis reallocated and (possibly) copied, which is an expensive operation.\nLinked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a\nspecific point of a list, assuming that a pointer is indexed to the node (before the one to be removed,\nor before the insertion point) already, is a constant-time operation (otherwise without this reference\nit is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the\nelements on average, and all the elements in the worst case. While one can \"delete\" an element from an\narray in constant time by somehow marking its slot as \"vacant\", this causes fragmentation that impedes\nthe performance of iteration.\nMoreover, arbitrarily many elements may be inserted into a linked list, limited only by the total\nmemory available; while a dynamic array will eventually fill up its underlying array data structure\nand will have to reallocate\u2014an expensive operation, one that may not even be possible if memory is\nfragmented, although the cost of reallocation can be averaged over insertions, and the cost of an\ninsertion due to reallocation would still be amortized O(1). This helps with appending elements at the\narray's end, but inserting into (or removing from) middle positions still carries prohibitive costs due\nto data moving to maintain contiguity. An array from which many elements are removed may also have to\nbe resized in order to avoid wasting too much space.\nOn the other hand, dynamic arrays (as well as fixed-size array data structures) allow constant-time\nrandom access, while linked lists allow only sequential access to elements. Singly linked lists, in\nfact, can be easily traversed in only one direction. This makes linked lists unsuitable for\napplications where it's useful to look up an element by its index quickly, such as heapsort. Sequential\naccess on arrays and dynamic arrays is also faster than on linked lists on many machines, because they\nhave optimal locality of reference and thus make good use of data caching.\nAnother disadvantage of linked lists is the extra storage needed for references, which often makes them\nimpractical for lists of small data items such as characters or Boolean values, because the storage\noverhead for the links may exceed by a factor of two or more the size of the data. In contrast, a\ndynamic array requires only the space for the data itself (and a very small amount of control data).\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What advantage do linked lists have over dynamic arrays for insertion?\n","icl_response_1":"Insertion in linked lists is constant time if you have a pointer to the position, without needing to\nshift elements.\n","icl_query_2":"Why are dynamic arrays better for random access?\n","icl_response_2":"They allow constant-time access to any element by index, unlike linked lists which require\nsequential traversal.\n","icl_query_3":"What is a drawback of linked lists in terms of storage?\n","icl_response_3":"They need extra space for pointers, which can be inefficient for small data items.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What data structure is used to create an internal storage linked list of families and their members in the given document?\n\nA) Tree\nB) Array\nC) Linked List\nD) Stack","mmlubench_answer":"C) Linked List","dataset_type":"mcq_qa","answer":2,"choices":["Tree","Array","Linked List","Stack"],"question":"What data structure is used to create an internal storage linked list of families and their members in the given document?"}
{"document":"Linked_list\nInternal and external storage\nSpeeding up search\nFinding a specific element in a linked list, even if it is sorted, normally requires O(n) time (linear search). This is one of the primary disadvantages of linked lists over other data structures. In addition to the variants discussed above, below are two simple ways to improve search time.\nIn an unordered list, one simple heuristic for decreasing average search time is the move-to-front heuristic, which simply moves an element to the beginning of the list once it is found. This scheme, handy for creating simple caches, ensures that the most recently used items are also the quickest to find again.\nAnother common approach is to \"index\" a linked list using a more efficient external data structure. For example, one can build a red\u2013black tree or hash table whose elements are references to the linked list nodes. Multiple such indexes can be built on a single list. The disadvantage is that these indexes may need to be updated each time a node is added or removed (or at least, before that index is used again).","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which heuristic is used to move an element to the beginning of a list after it has been found in an unordered linked list?\n\nA) Move-to-last\nB) Move-to-middle\nC) Move-to-front\nD) Move-to-end","mmlubench_answer":"C) Move-to-front","dataset_type":"mcq_qa","answer":2,"choices":["Move-to-last","Move-to-middle","Move-to-front","Move-to-end"],"question":"Which heuristic is used to move an element to the beginning of a list after it has been found in an unordered linked list?"}
{"document":"Linked_list\nInternal and external storage\nRandom-access lists\nA random-access list is a list with support for fast random access to read or modify any element in the list. One possible implementation is a skew binary random-access list using the skew binary number system, which involves a list of trees with special properties; this allows worst-case constant time head\/cons operations, and worst-case logarithmic time random access to an element by index. Random-access lists can be implemented as persistent data structures.\nRandom-access lists can be viewed as immutable linked lists in that they likewise support the same O(1) head and tail operations.\nA simple extension to random-access lists is the min-list, which provides an additional operation that yields the minimum element in the entire list in constant time (without mutation complexities).","icl_document":"Singly linked lists contain nodes which have a 'value' field as well as 'next' field, which points to\nthe next node in line of nodes. Operations that can be performed on singly linked lists include\ninsertion, deletion and traversal.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What defines a singly linked list?\n","icl_response_1":"It has nodes with a value and a next field pointing to the following node.\n","icl_query_2":"What basic operations can be done on singly linked lists?\n","icl_response_2":"Insertion, deletion, and traversal of nodes.\n","icl_query_3":"How does traversal work in a singly linked list?\n","icl_response_3":"Start at the head and follow the next pointers until the end.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is a random-access list in data structures?\n\nA) A list that can only be accessed sequentially from the beginning\nB) A list with support for fast random access to read or modify any element\nC) An implementation of a linked list using skew binary number system\nD) A data structure used for storing minimum values only","mmlubench_answer":"B) A list with support for fast random access to read or modify any element","dataset_type":"mcq_qa","answer":1,"choices":["A list that can only be accessed sequentially from the beginning","A list with support for fast random access to read or modify any element","An implementation of a linked list using skew binary number system","A data structure used for storing minimum values only"],"question":"What is a random-access list in data structures?"}
{"document":"Linked_list\nInternal and external storage\nRandom-access lists\nA random-access list is a list with support for fast random access to read or modify any element in the list. One possible implementation is a skew binary random-access list using the skew binary number system, which involves a list of trees with special properties; this allows worst-case constant time head\/cons operations, and worst-case logarithmic time random access to an element by index. Random-access lists can be implemented as persistent data structures.\nRandom-access lists can be viewed as immutable linked lists in that they likewise support the same O(1) head and tail operations.\nA simple extension to random-access lists is the min-list, which provides an additional operation that yields the minimum element in the entire list in constant time (without mutation complexities).","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What is a random-access list and what makes it different from an ordinary list?\n\nA) A random-access list is a type of data structure that allows for fast access to any element in the list without having to traverse the entire list. It differs from an ordinary list in that it provides worst-case constant time head\/cons operations and worst-case logarithmic time random access to an element by index.\n\nB) A random-access list is a type of data structure that can only be accessed sequentially, unlike an ordinary list which can be accessed randomly.\n\nC) A random-access list is a type of linked list where each node contains a random number as its key, making it easier to access any node directly.\n\nD) A random-access list is a type of data structure that uses skew binary trees for implementation and provides constant time head\/cons operations and logarithmic time random access.","mmlubench_answer":"D) A random-access list is a type of data structure that uses skew binary trees for implementation and provides constant time head\/cons operations and logarithmic time random access.","dataset_type":"mcq_qa","answer":3,"choices":["A random-access list is a type of data structure that allows for fast access to any element in the list without having to traverse the entire list. It differs from an ordinary list in that it provides worst-case constant time head\/cons operations and worst-case logarithmic time random access to an element by index.","A random-access list is a type of data structure that can only be accessed sequentially, unlike an ordinary list which can be accessed randomly.","A random-access list is a type of linked list where each node contains a random number as its key, making it easier to access any node directly.","A random-access list is a type of data structure that uses skew binary trees for implementation and provides constant time head\/cons operations and logarithmic time random access."],"question":"What is a random-access list and what makes it different from an ordinary list?"}
{"document":"Linked_list\nInternal and external storage\nRandom-access lists\nA random-access list is a list with support for fast random access to read or modify any element in the list. One possible implementation is a skew binary random-access list using the skew binary number system, which involves a list of trees with special properties; this allows worst-case constant time head\/cons operations, and worst-case logarithmic time random access to an element by index. Random-access lists can be implemented as persistent data structures.\nRandom-access lists can be viewed as immutable linked lists in that they likewise support the same O(1) head and tail operations.\nA simple extension to random-access lists is the min-list, which provides an additional operation that yields the minimum element in the entire list in constant time (without mutation complexities).","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"What operation does the min-list extension provide in a random-access list?\n\nA) An operation to remove the minimum element from the list\nB) An operation to add an element to the list\nC) An operation to modify an existing element in the list\nD) An operation to yield the minimum element in the entire list in constant time.","mmlubench_answer":"D) An operation to yield the minimum element in the entire list in constant time.","dataset_type":"mcq_qa","answer":3,"choices":["An operation to remove the minimum element from the list","An operation to add an element to the list","An operation to modify an existing element in the list","An operation to yield the minimum element in the entire list in constant time."],"question":"What operation does the min-list extension provide in a random-access list?"}
{"document":"Linked_list\nFurther reading\nJuan, Angel (2006). \"Ch20 \u2013Data Structures; ID06 - PROGRAMMING with JAVA (slide part of the book 'Big Java', by CayS. Horstmann)\" (PDF). p. 3. Archived from the original (PDF) on 2012-01-06. Retrieved 2011-07-10.\nBlack, Paul E. (2004-08-16). Pieterse, Vreda; Black, Paul E. (eds.). \"linked list\". Dictionary of Algorithms and Data Structures. National Institute of Standards and Technology. Retrieved 2004-12-14.\nAntonakos, James L.; Mansfield, Kenneth C. Jr. (1999). Practical Data Structures Using C\/C++. Prentice-Hall. pp. 165\u2013190. ISBN 0-13-280843-9.\nCollins, William J. (2005) [2002]. Data Structures and the Java Collections Framework. New York: McGraw Hill. pp. 239\u2013303. ISBN 0-07-282379-8.\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2003). Introduction to Algorithms. MIT Press. pp. 205\u2013213, 501\u2013505. ISBN 0-262-03293-7.\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001). \"10.2: Linked lists\". Introduction to Algorithms (2nd ed.). MIT Press. pp. 204\u2013209. ISBN 0-262-03293-7.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which sources were cited in the discussion about data structures and linked lists?\n\nA) Juan, Angel (2006) and Black, Paul E. (2004-08-16)\nB) Antonakos, James L.; Mansfield, Kenneth C. Jr. (1999) and Collins, William J. (2005)\nC) Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2003 and 2001)\nD) All of the above","mmlubench_answer":"D) All of the above","dataset_type":"mcq_qa","answer":3,"choices":["Juan, Angel (2006) and Black, Paul E. (2004-08-16)","Antonakos, James L.; Mansfield, Kenneth C. Jr. (1999) and Collins, William J. (2005)","Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2003 and 2001)","All of the above"],"question":"Which sources were cited in the discussion about data structures and linked lists?"}
{"document":"Linked_list\nFurther reading\nJuan, Angel (2006). \"Ch20 \u2013Data Structures; ID06 - PROGRAMMING with JAVA (slide part of the book 'Big Java', by CayS. Horstmann)\" (PDF). p. 3. Archived from the original (PDF) on 2012-01-06. Retrieved 2011-07-10.\nBlack, Paul E. (2004-08-16). Pieterse, Vreda; Black, Paul E. (eds.). \"linked list\". Dictionary of Algorithms and Data Structures. National Institute of Standards and Technology. Retrieved 2004-12-14.\nAntonakos, James L.; Mansfield, Kenneth C. Jr. (1999). Practical Data Structures Using C\/C++. Prentice-Hall. pp. 165\u2013190. ISBN 0-13-280843-9.\nCollins, William J. (2005) [2002]. Data Structures and the Java Collections Framework. New York: McGraw Hill. pp. 239\u2013303. ISBN 0-07-282379-8.\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2003). Introduction to Algorithms. MIT Press. pp. 205\u2013213, 501\u2013505. ISBN 0-262-03293-7.\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001). \"10.2: Linked lists\". Introduction to Algorithms (2nd ed.). MIT Press. pp. 204\u2013209. ISBN 0-262-03293-7.","icl_document":"In computer science, a linked list is a linear collection of data elements whose order is not given\nby their physical placement in memory. Instead, each element points to the next. It is a data\nstructure consisting of a collection of nodes which together represent a sequence. In its most basic\nform, each node contains data, and a reference (in other words, a link) to the next node in the\nsequence. This structure allows for efficient insertion or removal of elements from any position in\nthe sequence during iteration. A drawback of linked lists is that data access time is linear in\nrespect to the number of nodes in the list. Because nodes are serially linked, accessing any node\nrequires that the prior node be accessed beforehand. Faster access, such as random access, is not\nfeasible. Arrays have better cache locality compared to linked lists.\nLinked lists are among the simplest and most common data structures. They can be used to implement\nseveral other common abstract data types, including lists, stacks, queues, associative arrays, and\nS-expressions. The principal benefit of a linked list over a conventional array is that the list\nelements can be easily inserted or removed without reallocation or reorganization of the entire\nstructure because the data items do not need to be stored contiguously in memory or on disk, while\nrestructuring an array at run-time is a much more expensive operation. Linked lists allow insertion\nand removal of nodes at any point in the list, and allow doing so with a constant number of\noperations by keeping the link previous to the link being added or removed in memory during list\ntraversal.\nOn the other hand, since simple linked lists by themselves do not allow random access to the data or\nany form of efficient indexing, many basic operations\u2014such as obtaining the last node of the list,\nfinding a node that contains a given datum, or locating the place where a new node should be inserted\n\u2014may require iterating through most or all of the list elements.\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a linked list?\n","icl_response_1":"A linked list is a linear collection of data elements where each element points to the next,\nforming a sequence of nodes. Each node has data and a link to the next node.\n","icl_query_2":"What is the main advantage of linked lists over arrays?\n","icl_response_2":"Linked lists allow easy insertion or removal of elements without reorganizing the entire structure,\nas elements don't need to be stored contiguously in memory.\n","icl_query_3":"Why is accessing data in a linked list slower than in an array?\n","icl_response_3":"Accessing data requires traversing nodes sequentially from the start, which takes linear time,\nunlike arrays that allow random access.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which book was cited as 'Big Java' by Cay S. Horstmann in the document?\n\nA) The book 'Practical Data Structures Using C\/C++' by Antonakos and Mansfield\nB) The book 'Data Structures and the Java Collections Framework' by Collins\nC) The book 'Introduction to Algorithms' by Cormen, Leiserson, Rivest, and Stein\nD) The book 'Ch20 \u2013Data Structures; ID06 - PROGRAMMING with JAVA' by Juan","mmlubench_answer":"D) The book 'Ch20 \u2013Data Structures; ID06 - PROGRAMMING with JAVA' by Juan","dataset_type":"mcq_qa","answer":3,"choices":["The book 'Practical Data Structures Using C\/C++' by Antonakos and Mansfield","The book 'Data Structures and the Java Collections Framework' by Collins","The book 'Introduction to Algorithms' by Cormen, Leiserson, Rivest, and Stein","The book 'Ch20 \u2013Data Structures; ID06 - PROGRAMMING with JAVA' by Juan"],"question":"Which book was cited as 'Big Java' by Cay S. Horstmann in the document?"}
{"document":"Linked_list\nFurther reading\nWilkes, Maurice Vincent (1964). \"An Experiment with a Self-compiling Compiler for a Simple List-Processing Language\". Annual Review in Automatic Programming. 4 (1). Pergamon Press: 1. doi:10.1016\/0066-4138(64)90013-8.\nWilkes, Maurice Vincent (1964). \"Lists and Why They are Useful\". Proceeds of the ACM National Conference, Philadelphia 1964 (P\u201364). ACM: F1\u20131.\nShanmugasundaram, Kulesh (2005-04-04). \"Linux Kernel Linked List Explained\". Archived from the original on 2009-09-25. Retrieved 2009-09-21.","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which documents discuss the concept of a linked list?\n\nA) The first document written by Maurice Vincent Wilkes in 1964\nB) An article published in the ACM National Conference, Philadelphia 1964\nC) A blog post from 2005 about Linux Kernel Linked List\nD) All of the above","mmlubench_answer":"D) All of the above","dataset_type":"mcq_qa","answer":3,"choices":["The first document written by Maurice Vincent Wilkes in 1964","An article published in the ACM National Conference, Philadelphia 1964","A blog post from 2005 about Linux Kernel Linked List","All of the above"],"question":"Which documents discuss the concept of a linked list?"}
{"document":"Linked_list\nFurther reading\nWilkes, Maurice Vincent (1964). \"An Experiment with a Self-compiling Compiler for a Simple List-Processing Language\". Annual Review in Automatic Programming. 4 (1). Pergamon Press: 1. doi:10.1016\/0066-4138(64)90013-8.\nWilkes, Maurice Vincent (1964). \"Lists and Why They are Useful\". Proceeds of the ACM National Conference, Philadelphia 1964 (P\u201364). ACM: F1\u20131.\nShanmugasundaram, Kulesh (2005-04-04). \"Linux Kernel Linked List Explained\". Archived from the original on 2009-09-25. Retrieved 2009-09-21.","icl_document":"In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing\nto the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or\n'next' and 'prev'('previous').\n","document_outline":"Overview of linked lists, covering their definition, basic concepts, types (singly and doubly linked),\ntradeoffs with dynamic arrays, and fundamental operations.\n","subject":"computer_science","leaf_node_type":"knowledge","icl_query_1":"What is a doubly linked list?\n","icl_response_1":"It is a linked list where each node has links to both the next and previous nodes.\n","icl_query_2":"What are the link fields in a doubly linked list called?\n","icl_response_2":"They are often called 'next' for the forward link and 'prev' for the backward link.\n","icl_query_3":"How does a doubly linked list differ from a singly linked list?\n","icl_response_3":"It allows traversal in both directions due to the previous link, unlike singly linked lists which\nonly go forward.\n","leaf_node_path":"knowledge_technology_computer_science_theory_data_structures_linked_list","mmlubench_question":"Which document provides a discussion on the usefulness of linked lists?\n\nA) The first document written by Maurice Vincent Wilkes in 1964\nB) An article published in the ACM National Conference, Philadelphia 1964\nC) A blog post from 2005 about Linux Kernel Linked List\nD) None of the above","mmlubench_answer":"B) 1964","dataset_type":"mcq_qa","answer":1,"choices":["The first document written by Maurice Vincent Wilkes in 1964","An article published in the ACM National Conference, Philadelphia 1964","A blog post from 2005 about Linux Kernel Linked List","None of the above"],"question":"Which document provides a discussion on the usefulness of linked lists?"}
